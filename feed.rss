<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Sookim-1 ğŸ˜</title><description>iOSê°œë°œ ë¸”ë¡œê·¸</description><link>https://sookim-1.github.io</link><language>ko</language><lastBuildDate>Sun, 7 Jan 2024 23:15:14 +0000</lastBuildDate><pubDate>Sun, 7 Jan 2024 23:15:14 +0000</pubDate><ttl>250</ttl><atom:link href="https://sookim-1.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://sookim-1.github.io/posts/003-20231205</guid><title>069 2023-12-05</title><description>TBD</description><link>https://sookim-1.github.io/posts/003-20231205</link><pubDate>Tue, 5 Dec 2023 09:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>069 2023-12-05</h1><h2>TBD</h2>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/004-20231206</guid><title>069 2023-12-05</title><description>TBD</description><link>https://sookim-1.github.io/posts/004-20231206</link><pubDate>Tue, 5 Dec 2023 09:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>069 2023-12-05</h1><h2>TBD</h2>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/002-20231204</guid><title>002-20231204</title><description>í…ŒìŠ¤íŠ¸1</description><link>https://sookim-1.github.io/posts/002-20231204</link><pubDate>Mon, 4 Dec 2023 09:00:00 +0000</pubDate><content:encoded><![CDATA[<h3>ê³ ë¯¼ì‚¬í•­</h3><ol><li>ì„œë²„ì—ì„œ URLì„ ì „ë‹¬ë°›ì•„ socketì„ ì—°ê²°í•˜ë ¤ê³  í–ˆëŠ”ë° sokcetì„ ì—°ê²°í•˜ê³  ê´€ë¦¬í•˜ëŠ” ê°ì²´ê°€ ì‹±ê¸€í†¤ê°ì²´ë¡œ êµ¬í˜„ë˜ì–´ ìˆì–´ì„œ ì–´ëŠì‹œì ì— ì„œë²„ì—ì„œ URLì„ ì „ë‹¬ë°›ëŠ”ì§€ì— ëŒ€í•´ì„œ ê³ ë¯¼<ul></ul></li></ol><ul><li>socketê´€ë¦¬í•˜ëŠ” ê°ì²´ (ConfigSCConnection.swift)<ul></ul></li></ul><pre><code class="language-swift">        // ì´ í´ë˜ìŠ¤ëŠ” ì„œë²„(SocketCluster)ì— ëŒ€í•œ ì—°ê²°ì„ ìœ ì§€í•˜ê³  ëª¨ë“  ìœ ìš©í•œ ë©”ì„œë“œë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤.
        final class ConfigSCConnection: PapaNSObject {
            
            // ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ë³€ìˆ˜ ì„ ì–¸
            static let shared = ConfigSCConnection()
            
            private override init() {}
            
            // clientê°€ sockect clusterì˜ ê°ì²´ì…ë‹ˆë‹¤. ì´ ê°ì²´ì˜ ë„ì›€ì„ ë°›ì•„ sockect clusterì— í•„ìš”í•œ ëª¨ë“  ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. sockect clusterê°€ íŠ¹ì • í¬íŠ¸ì—ì„œ ì‹¤í–‰ë˜ê³  ìˆìœ¼ë©° ì–¸ê¸‰ëœ í¬íŠ¸ëŠ” ëª¨ë“  ì—°ê²°(ê³µìš© í¬íŠ¸)ì— ëŒ€í•´ ì—´ë ¤ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
            private var client = ScClient(url: Config.generalConfigData["SC_CONNECT_URL"].stringValue)
            
            // êµ¬ë…í•˜ê³  ìˆëŠ” ì±„ë„ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ë°°ì—´
            var listOfSubscribedList = [String]()
            
            // êµ¬ë…í•˜ì§€ ì•ŠëŠ” ì±„ë„ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ë°°ì—´
            var listOfNotSubscribedList = [String]()
            
            // ì•±ê³¼ ì„œë²„ê°„ì˜ ì—°ê²°ì„ ìˆ˜í–‰í•˜ëŠ” task
            private var reConnectionFreqTask: UpdateFreqTask!
            
            // ì†Œì¼“ ì—°ê²°ì•ˆë˜ì–´ìˆì„ ë•Œ HTTPí†µì‹ í•˜ëŠ” task
            private var updateTripStatusFreqTask: UpdateFreqTask!
            
            // 5ì´ˆë§ˆë‹¤ ì±„ë„ êµ¬ë… í›„ ì´ë²¤íŠ¸ ìˆ˜ì‹ í•˜ëŠ” task
            private var subscribeTask: UpdateFreqTask!
            
            // ì±„ë„ì— êµ¬ë…í•˜ëŠ” ì¤‘ì¸ì§€ ê²€ì‚¬í•˜ëŠ” ë³€ìˆ˜
            private var isChannelSubscribing = false
            
            private var disposeBag = DisposeBag()
            
            
            // TODO: ì†Œì¼“ ê´€ë ¨ ì´ˆê¸° ì§„ì…ì 
            // í•´ë‹¹ ë©”ì„œë“œëŠ” ì–¸ê¸‰ëœ ì„œë²„ì™€ ì†Œì¼“ í´ëŸ¬ìŠ¤í„°ì˜ ë„ì›€ìœ¼ë¡œ ì†Œì¼“ ì—°ê²°ì„ ë§Œë“¤ ê²ƒì…ë‹ˆë‹¤. ì´ê²ƒì€ ì•±ì˜ ê° ì„¸ì…˜ì—ì„œ í•œ ë²ˆì”© í˜¸ì¶œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
            func buildConnection() {
                log.verbose("ì†Œì¼“ ì—°ê²° ì‹œì‘")
                
                // ì—°ê²°ë˜ì–´ìˆìœ¼ë©´ ì¢…ë£Œ
                if client.isConnected() {
                    return
                }
                
                // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ëŒì•„ì˜¬ ë•Œ ë…¸í‹°ì²˜ë¦¬
                resetDidEnterBackgroundNoti()
                resetWillResignActiveNoti()
                
                // ì—¬ì •ìƒíƒœ ì—…ë°ì´íŠ¸ ì£¼ê¸°
                let serverFetchTripStatusTimeInterval = Config.generalConfigData["FETCH_TRIP_STATUS_TIME_INTERVAL"].stringValue.isEmpty == false ? (Config.generalConfigData["FETCH_TRIP_STATUS_TIME_INTERVAL"].stringValue) : "15"
                
                updateTripStatusFreqTask = UpdateFreqTask(interval: Utillity.parseDouble(origValue: 15, data: serverFetchTripStatusTimeInterval), category: .tripStatus)
                updateTripStatusFreqTask.onTaskRunCalledDelegate = self
                updateTripStatusFreqTask.startRepeatingTask()
                
                // ê¸°ë³¸ ì—°ê²° ìˆ˜ì‹ ê¸°ì…ë‹ˆë‹¤. ì—°ê²° ê´€ë ¨ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©´ ì´ ìˆ˜ì‹ ê¸°ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.
                client.setBasicListener(onConnect: { [weak self] (scClient) in
                    guard let self = self
                    else { return }
                    
                    // ì†Œì¼“ ì—°ê²°ì´ ì„¤ì •ë˜ë©´ í˜¸ì¶œë©ë‹ˆë‹¤.
                    log.verbose("onConnect")
                    
                    self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                    
                    if UserDefaults.iUserId.isEmpty {
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        
                        return
                    }
                    
                    self.subscribeTask = UpdateFreqTask(interval: 5, category: .subscribe)
                    self.subscribeTask.onTaskRunCalledDelegate = self
                    self.subscribeTask.startRepeatingTask()
                    
                }, onConnectError: { [weak self] (scClient, error) in
                    guard let self = self else { return }
                    // ì†Œì¼“ ì—°ê²° ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ í˜¸ì¶œë©ë‹ˆë‹¤.
                    log.verbose("onConnectError")
                    self.reConnectClient()
                }, onDisconnect: { [weak self] (scClient, error) in
                    guard let self = self else { return }
                    log.verbose("onDisconnect")
                    // ì†Œì¼“ ì—°ê²°ì— ì‹¤íŒ¨í•˜ë©´ í˜¸ì¶œë©ë‹ˆë‹¤.
                    
                    if UserDefaults.iUserId.isEmpty {
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        
                        return
                    }
                    
                    self.reConnectClient()
                })
                
                // ì†Œì¼“ í´ëŸ¬ìŠ¤í„°ë¥¼ ì—°ê²°í•˜ê¸° ìœ„í•´ í˜¸ì¶œë©ë‹ˆë‹¤.
                client.connect()
            }
            
            func disconnection() {
                self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                self.resetUpdateFreqTask(&amp;self.subscribeTask)
                self.client.disconnect()
            }
            
            private func resetUpdateFreqTask(_ task: inout UpdateFreqTask?) {
                if task != nil {
                    task?.stopRepeatingTask()
                    task = nil
                }
            }
            
            // ì—°ê²° ì‹¤íŒ¨/ì—°ê²° í•´ì œ ì‹œ ì†Œì¼“ ì—°ê²°ì„ ë‹¤ì‹œ ì—°ê²°í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.
            private func reConnectClient() {
                if reConnectionFreqTask != nil {
                    return
                }
                
                self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                reConnectionFreqTask = UpdateFreqTask(interval: 15, category: .reConnection)
                reConnectionFreqTask.onTaskRunCalledDelegate = self
                reConnectionFreqTask.startRepeatingTask()
            }
            
            // ì´ ë©”ì„œë“œëŠ” ì„œë²„ì— ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— ì±„ë„ì„ êµ¬ë…í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
            private func continueChannelSubscribe() {
                self.isChannelSubscribing = false
                
                // ì „ë¶€ êµ¬ë… ì·¨ì†Œ í›„ ì¬êµ¬ë…
                self.releaseAllChannels()
            
                self.unSubscribeFromChannels(channelName: "\(Config.passengerChannelName)")
                self.unSubscribeFromChannels(channelName: "\(Config.passengerChannelName)\(UserDefaults.iUserId)")
                
                self.subscribeToChannels(channelName: "\(Config.passengerChannelName)\(UserDefaults.iUserId)")
                
                listOfSubscribedList
                    .filter { $0.isEmpty == false }
                    .forEach {
                        self.subscribeToChannels(channelName: $0)
                    }
            }
            
            // ì†Œì¼“í†µì‹  ìˆ˜ì‹  : ì´ ë©”ì„œë“œëŠ” ì±„ë„ì„ êµ¬ë…í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. (Publish-Subscribe module)
            private func subscribeToChannels(channelName: String) {   // ì†Œìº£í†µì‹  ìˆ˜ì‹ 
                log.verbose("channelName = \(channelName)")
                
                if channelName.isEmpty {
                    return
                }
                
                if UserDefaults.iUserId.isEmpty {
                    resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                    resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                    resetUpdateFreqTask(&amp;self.subscribeTask)
                    
                    return
                }
                
                if channelName.isEmpty == false {
                    if listOfSubscribedList.contains(channelName) == false {
                        listOfSubscribedList += [channelName]
                    }
                    
                    if client.isConnected() == false {
                        return
                    }
                    
                    if isChannelSubscribing == true {
                        listOfNotSubscribedList += [channelName]
                        
                        return
                    }
                    
                    isChannelSubscribing = true
                    
                    // ìŠ¹ì¸ì„ ë°›ì•„ ìƒˆì±„ë„ì„ êµ¬ë…í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
                    client.subscribeAck(channelName: channelName, ack: {
                        [weak self] (channelName: String, error: AnyObject?, data: AnyObject?) in
                        guard let self = self else { return }
                        
                        self.isChannelSubscribing = false
                        
                        if (error is NSNull) == false {
                            log.verbose("ì†Œì¼“ í†µì‹  ì—ëŸ¬ ë°œìƒ : \(String(describing: error))")
                        } else {
                            // íŠ¹ì • ì±„ë„ êµ¬ë…ì— ì„±ê³µí•˜ë©´ í•´ë‹¹ ì±„ë„ì—ì„œ ì²­ì·¨ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
                            self.client.onChannel(channelName: channelName, ack: { (channelName: String, data: AnyObject?) in
                                // ì´ë²¤íŠ¸ ì•Œë¦¼ì´ ë„ì°©í•˜ë©´ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
                                let datas = JSON(data as Any)
                                let bodyStrig = datas.stringValue
                                let realBody = JSON(bodyStrig.getJsonDataDict())
                                log.verbose("ì†Œì¼“ í†µì‹  ì‘ë‹µê°’ : \(channelName) :: \(datas)")
                                
                                // PQ-1808 ì˜ˆì•½ì—¬ì •ì‹œ ë©”ì¸ì—ì„œ ë°›ì§€ ì•ŠëŠ” ê²½ìš°
                                if realBody["Message"].stringValue == TripStatusActive.cabRequestAccepted.rawValue ||
                                    realBody["MsgType"].stringValue == TripStatusActive.cabRequestAccepted.rawValue {
                                    
                                    if Config.mainLoadCheck == false {
                                        NotificationCenter.default.post(name: .reserveTripNoti, object: nil)
                                        return
                                    }
                                } else if (realBody["Message"].stringValue == TripStatusActive.reservedConfirm.rawValue) {
                                    
                                    self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                    NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                    return
                                } else if (realBody["Message"].stringValue == TripStatusActive.reservedFailed.rawValue) {
                                    
                                    self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                    NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                    return
                                } else if (realBody["Message"].stringValue == TripStatusActive.tripCancelledByDriver.rawValue) {
                                    // ì˜ˆì•½ í™•ì • í›„ ì·¨ì†Œí•˜ëŠ” ê²½ìš° TripCancelledByDriverë¡œ ë‚´ë ¤ì™€ì„œ ë©”ì¸í™”ë©´ ì•„ë‹Œ ê²½ìš° ì²˜ë¦¬
                                    if Config.mainLoadCheck == false {
                                        
                                        self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                        
                                        NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                        
                                        return
                                    }
                                }
                                
                                NotificationCenter.default.post(name: .updateTripStatusNoti, object: realBody)
                            })
                            
                            if self.listOfNotSubscribedList.isEmpty == false {
                                let newChannel = self.listOfNotSubscribedList[0]
                                self.listOfNotSubscribedList.remove(at: 0)
                                
                                if newChannel.isEmpty == false {
                                    self.subscribeToChannels(channelName: newChannel)
                                }
                            }
                        }
                    })
                }
            }
            
            // íŠ¹ì • ì±„ë„ì—ì„œ ì‚¬ìš©ìêµ¬ë…ì„ ì·¨ì†Œí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.
            private func unSubscribeFromChannels(channelName: String) {
                if channelName.isEmpty == false {
                    if listOfSubscribedList.contains(channelName) {
                        client.unsubscribeAck(channelName: channelName, ack: { [weak self] (channelName, error, data) in
                            guard let self = self else { return }
                            
                            if (error is NSNull) == false {
                                log.error("êµ¬ë… ì·¨ì†Œ ì¤‘ ì—ëŸ¬ ë°œìƒ")
                            } else {
                                if let index = self.listOfSubscribedList.firstIndex(of: channelName) {
                                    self.listOfSubscribedList.remove(at: index)
                                }
                            }
                        })
                    }
                }
            }
            
            // ëª¨ë“  ì±„ë„ êµ¬ë…ì„ ì·¨ì†Œí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì´ ì‘ì—…ì€ ì•±ì´ ì¢…ë£Œë  ë•Œ ìˆ˜í–‰ë©ë‹ˆë‹¤.
            private func releaseAllChannels() {
                listOfSubscribedList.forEach {
                    unSubscribeFromChannels(channelName: $0)
                }
            }
            
            private func resetDidEnterBackgroundNoti() {
                NotificationCenter
                    .default
                    .rx
                    .notification(.applicationDidBackgroundNoti)
                    .subscribe(onNext: { [weak self] (aNotification) in
                        guard let self = self else { return }
                        
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        self.client.disconnect()
                    })
                    .disposed(by: disposeBag)
            }
            
            private func resetWillResignActiveNoti() {
                NotificationCenter
                    .default
                    .rx
                    .notification(.applicationWillResignActiveNoti)
                    .subscribe(onNext: { [weak self] (aNotification) in
                        guard let self = self else { return }
                        
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        self.client.disconnect()
                    })
                    .disposed(by: disposeBag)
            }
            
            
            // ì—°ê²° ì•ˆë˜ì–´ìˆì„ ë•Œ HTTP ìš”ì²­
            // TODO: configPassengerTripStatus API message í‚¤ ê°’ íƒ€ì…ì´ ì •í™•íˆ ì˜¤ì§€ ì•Šì•„ì„œ ì†Œì¼“ ëŒ€ë¹„ì—ì„œë§Œ JSONì²˜ë¦¬
            private func requestConfigPassengerTripStatus() {
                if PlanConfig.currentLocation != nil {
                    Connection.configPassengerTripStatusJSON(vLatitude: "\(PlanConfig.currentLocation.coordinate.latitude)", vLongitude: "\(PlanConfig.currentLocation.coordinate.longitude)") { [weak self] (returnDatas, status) in
                        guard let self = self else { return }
                        
                        if status {
                            let dataDict = JSON(returnDatas as Any)
                            log.verbose("dataDict : \(dataDict)")
                            PlanConfig.vTripCancelConfirmMessage = dataDict["vTripCancelConfirmMessage"].stringValue
                            PlanConfig.vTripCancelDispatchTimeMessage = dataDict["vTripCancelDispatchTimeMessage"].stringValue
                            PlanConfig.vTripCancelFeesMessageConfirm = dataDict["vTripCancelFeesMessageConfirm"].stringValue
                            PlanConfig.vTripCancelFeesMessage = dataDict["vTripCancelFeesMessage"].stringValue
                            
                            let currentDrivers = dataDict["currentDrivers"].arrayValue
                            
                            if currentDrivers.isEmpty == false {
                                currentDrivers.forEach { value in
                                    let rowData = JSON(value)
                                    
                                    if PlanConfig.joinDriverId == rowData["iDriverId"].stringValue {
                                        PlanConfig.joinDriverLocation = CLLocation(latitude: rowData["vLatitude"].doubleValue, longitude: rowData["vLongitude"].doubleValue)
                                    }
                                    
                                    let bodyStrig = dataDict["message"].stringValue
                                    let realBody = JSON(bodyStrig.getJsonDataDict())
                                    log.verbose("configPassengerTripStatus í™•ì¸í•˜ê¸°A :: \(realBody)")
                                    
                                    // PQ-1808 ì˜ˆì•½ì—¬ì •ì‹œ ë©”ì¸ì—ì„œ ë°›ì§€ ì•ŠëŠ” ê²½ìš°
                                    if realBody["Message"].stringValue == TripStatusActive.cabRequestAccepted.rawValue ||
                                        realBody["MsgType"].stringValue == TripStatusActive.cabRequestAccepted.rawValue {
                                        
                                        if Config.mainLoadCheck == false {
                                            NotificationCenter.default.post(name: .reserveTripNoti, object: nil)
                                            return
                                        }
                                    } else if (realBody["Message"].stringValue == TripStatusActive.reservedConfirm.rawValue) {
                                        
                                        self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                        NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                        return
                                    } else if (realBody["Message"].stringValue == TripStatusActive.reservedFailed.rawValue) {
                                        
                                        self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                        NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                        return
                                    } else if (realBody["Message"].stringValue == TripStatusActive.tripCancelledByDriver.rawValue) {
                                        // ì˜ˆì•½ í™•ì • í›„ ì·¨ì†Œí•˜ëŠ” ê²½ìš° TripCancelledByDriverë¡œ ë‚´ë ¤ì™€ì„œ ë©”ì¸í™”ë©´ ì•„ë‹Œ ê²½ìš° ì²˜ë¦¬
                                        if Config.mainLoadCheck == false {
                                            
                                            self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                            
                                            NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                            
                                            return
                                        }
                                    }
                                    
                                    NotificationCenter.default.post(name: .updateTripStatusNoti, object: realBody)
                                }
                            }
                        } else {
                            let dataDict = JSON(returnDatas as Any)
                            
                            if dataDict["message"].stringValue == "SESSION_OUT" {
                                log.verbose("SESSION_OUT_CALLED")
                                return
                            }
                        }
                    }
                }
            }
            
            // ì˜ˆì•½ í™•ì •, ì·¨ì†Œ ì•Œë¦¼ìš© ë©”ì„œë“œ
            private func openCommonPopup(message: String) {
                let mainStoryboard: UIStoryboard = UIStoryboard(name: "CommonPopupViewController", bundle: nil)
                let nextView = mainStoryboard.instantiateViewController(withIdentifier: "CommonPopupView") as! CommonPopupViewController
                let topView = Utillity.topViewController()
                
                if Utillity.isTypeViewController(type: CommonPopupViewController.self) {
                    topView?.dismiss(animated: true) {
                        let nextTopView = Utillity.topViewController()
                        nextView.titleString = "ì•Œë¦¼"
                        nextView.messageString = message
                        nextView.doneBtnString = "í™•ì¸"
                        
                        nextTopView?.present(nextView, animated: false)
                    }
                } else {
                    let nextTopView = Utillity.topViewController()
                    nextView.titleString = "ì•Œë¦¼"
                    nextView.messageString = message
                    nextView.doneBtnString = "í™•ì¸"
                    
                    nextTopView?.present(nextView, animated: false)
                }
            }
            
        }
        ```
        
    
    â†’ í˜„ì¬ëŠ” ì„œë²„ì— URLìš”ì²­í•˜ëŠ” APIí˜¸ì¶œì„ Launchí™”ë©´ì—ì„œ í˜¸ì¶œí•˜ëŠ”ë° í•­ìƒ ì‹±ê¸€í†¤ì¸ìŠ¤í„´ìŠ¤ìƒì„±ì‹œì ë³´ë‹¤ ë¨¼ì € í˜¸ì¶œì´ ë˜ëŠ” ê²ƒì¸ê°€?
    
    ì¼ë‹¨ ê¸°ë³¸ì ìœ¼ë¡œ Swiftì—ì„œ ì „ì—­ë³€ìˆ˜ë“¤ì€ ëª¨ë‘ lazyê°€ ê¸°ë³¸ì ìœ¼ë¡œ ì ìš©ëœ ìƒíƒœì´ë¯€ë¡œ lazyë¥¼ ì‚¬ìš©í•´ë„ ë˜‘ê°™ìŠµë‹ˆë‹¤ë‹¤. ì¦‰, ì‹±ê¸€í†¤ ê°ì²´ëŠ” ì‚¬ìš©ë˜ëŠ” ì‹œì ì— ë©”ëª¨ë¦¬ì— í• ë‹¹ë©ë‹ˆë‹¤.
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/001-20231203</guid><title>001-20231203</title><description>í…ŒìŠ¤íŠ¸</description><link>https://sookim-1.github.io/posts/001-20231203</link><pubDate>Sun, 3 Dec 2023 09:00:00 +0000</pubDate><content:encoded><![CDATA[<h3>ê³ ë¯¼ì‚¬í•­</h3><ol><li>ì„œë²„ì—ì„œ URLì„ ì „ë‹¬ë°›ì•„ socketì„ ì—°ê²°í•˜ë ¤ê³  í–ˆëŠ”ë° sokcetì„ ì—°ê²°í•˜ê³  ê´€ë¦¬í•˜ëŠ” ê°ì²´ê°€ ì‹±ê¸€í†¤ê°ì²´ë¡œ êµ¬í˜„ë˜ì–´ ìˆì–´ì„œ ì–´ëŠì‹œì ì— ì„œë²„ì—ì„œ URLì„ ì „ë‹¬ë°›ëŠ”ì§€ì— ëŒ€í•´ì„œ ê³ ë¯¼<ul></ul></li></ol><ul><li>socketê´€ë¦¬í•˜ëŠ” ê°ì²´ (ConfigSCConnection.swift)<ul></ul></li></ul><pre><code class="language-swift">        // ì´ í´ë˜ìŠ¤ëŠ” ì„œë²„(SocketCluster)ì— ëŒ€í•œ ì—°ê²°ì„ ìœ ì§€í•˜ê³  ëª¨ë“  ìœ ìš©í•œ ë©”ì„œë“œë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤.
        final class ConfigSCConnection: PapaNSObject {
            
            // ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ë³€ìˆ˜ ì„ ì–¸
            static let shared = ConfigSCConnection()
            
            private override init() {}
            
            // clientê°€ sockect clusterì˜ ê°ì²´ì…ë‹ˆë‹¤. ì´ ê°ì²´ì˜ ë„ì›€ì„ ë°›ì•„ sockect clusterì— í•„ìš”í•œ ëª¨ë“  ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. sockect clusterê°€ íŠ¹ì • í¬íŠ¸ì—ì„œ ì‹¤í–‰ë˜ê³  ìˆìœ¼ë©° ì–¸ê¸‰ëœ í¬íŠ¸ëŠ” ëª¨ë“  ì—°ê²°(ê³µìš© í¬íŠ¸)ì— ëŒ€í•´ ì—´ë ¤ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
            private var client = ScClient(url: Config.generalConfigData["SC_CONNECT_URL"].stringValue)
            
            // êµ¬ë…í•˜ê³  ìˆëŠ” ì±„ë„ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ë°°ì—´
            var listOfSubscribedList = [String]()
            
            // êµ¬ë…í•˜ì§€ ì•ŠëŠ” ì±„ë„ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ë°°ì—´
            var listOfNotSubscribedList = [String]()
            
            // ì•±ê³¼ ì„œë²„ê°„ì˜ ì—°ê²°ì„ ìˆ˜í–‰í•˜ëŠ” task
            private var reConnectionFreqTask: UpdateFreqTask!
            
            // ì†Œì¼“ ì—°ê²°ì•ˆë˜ì–´ìˆì„ ë•Œ HTTPí†µì‹ í•˜ëŠ” task
            private var updateTripStatusFreqTask: UpdateFreqTask!
            
            // 5ì´ˆë§ˆë‹¤ ì±„ë„ êµ¬ë… í›„ ì´ë²¤íŠ¸ ìˆ˜ì‹ í•˜ëŠ” task
            private var subscribeTask: UpdateFreqTask!
            
            // ì±„ë„ì— êµ¬ë…í•˜ëŠ” ì¤‘ì¸ì§€ ê²€ì‚¬í•˜ëŠ” ë³€ìˆ˜
            private var isChannelSubscribing = false
            
            private var disposeBag = DisposeBag()
            
            
            // TODO: ì†Œì¼“ ê´€ë ¨ ì´ˆê¸° ì§„ì…ì 
            // í•´ë‹¹ ë©”ì„œë“œëŠ” ì–¸ê¸‰ëœ ì„œë²„ì™€ ì†Œì¼“ í´ëŸ¬ìŠ¤í„°ì˜ ë„ì›€ìœ¼ë¡œ ì†Œì¼“ ì—°ê²°ì„ ë§Œë“¤ ê²ƒì…ë‹ˆë‹¤. ì´ê²ƒì€ ì•±ì˜ ê° ì„¸ì…˜ì—ì„œ í•œ ë²ˆì”© í˜¸ì¶œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
            func buildConnection() {
                log.verbose("ì†Œì¼“ ì—°ê²° ì‹œì‘")
                
                // ì—°ê²°ë˜ì–´ìˆìœ¼ë©´ ì¢…ë£Œ
                if client.isConnected() {
                    return
                }
                
                // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ëŒì•„ì˜¬ ë•Œ ë…¸í‹°ì²˜ë¦¬
                resetDidEnterBackgroundNoti()
                resetWillResignActiveNoti()
                
                // ì—¬ì •ìƒíƒœ ì—…ë°ì´íŠ¸ ì£¼ê¸°
                let serverFetchTripStatusTimeInterval = Config.generalConfigData["FETCH_TRIP_STATUS_TIME_INTERVAL"].stringValue.isEmpty == false ? (Config.generalConfigData["FETCH_TRIP_STATUS_TIME_INTERVAL"].stringValue) : "15"
                
                updateTripStatusFreqTask = UpdateFreqTask(interval: Utillity.parseDouble(origValue: 15, data: serverFetchTripStatusTimeInterval), category: .tripStatus)
                updateTripStatusFreqTask.onTaskRunCalledDelegate = self
                updateTripStatusFreqTask.startRepeatingTask()
                
                // ê¸°ë³¸ ì—°ê²° ìˆ˜ì‹ ê¸°ì…ë‹ˆë‹¤. ì—°ê²° ê´€ë ¨ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©´ ì´ ìˆ˜ì‹ ê¸°ê°€ í˜¸ì¶œë©ë‹ˆë‹¤.
                client.setBasicListener(onConnect: { [weak self] (scClient) in
                    guard let self = self
                    else { return }
                    
                    // ì†Œì¼“ ì—°ê²°ì´ ì„¤ì •ë˜ë©´ í˜¸ì¶œë©ë‹ˆë‹¤.
                    log.verbose("onConnect")
                    
                    self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                    
                    if UserDefaults.iUserId.isEmpty {
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        
                        return
                    }
                    
                    self.subscribeTask = UpdateFreqTask(interval: 5, category: .subscribe)
                    self.subscribeTask.onTaskRunCalledDelegate = self
                    self.subscribeTask.startRepeatingTask()
                    
                }, onConnectError: { [weak self] (scClient, error) in
                    guard let self = self else { return }
                    // ì†Œì¼“ ì—°ê²° ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ í˜¸ì¶œë©ë‹ˆë‹¤.
                    log.verbose("onConnectError")
                    self.reConnectClient()
                }, onDisconnect: { [weak self] (scClient, error) in
                    guard let self = self else { return }
                    log.verbose("onDisconnect")
                    // ì†Œì¼“ ì—°ê²°ì— ì‹¤íŒ¨í•˜ë©´ í˜¸ì¶œë©ë‹ˆë‹¤.
                    
                    if UserDefaults.iUserId.isEmpty {
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        
                        return
                    }
                    
                    self.reConnectClient()
                })
                
                // ì†Œì¼“ í´ëŸ¬ìŠ¤í„°ë¥¼ ì—°ê²°í•˜ê¸° ìœ„í•´ í˜¸ì¶œë©ë‹ˆë‹¤.
                client.connect()
            }
            
            func disconnection() {
                self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                self.resetUpdateFreqTask(&amp;self.subscribeTask)
                self.client.disconnect()
            }
            
            private func resetUpdateFreqTask(_ task: inout UpdateFreqTask?) {
                if task != nil {
                    task?.stopRepeatingTask()
                    task = nil
                }
            }
            
            // ì—°ê²° ì‹¤íŒ¨/ì—°ê²° í•´ì œ ì‹œ ì†Œì¼“ ì—°ê²°ì„ ë‹¤ì‹œ ì—°ê²°í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.
            private func reConnectClient() {
                if reConnectionFreqTask != nil {
                    return
                }
                
                self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                reConnectionFreqTask = UpdateFreqTask(interval: 15, category: .reConnection)
                reConnectionFreqTask.onTaskRunCalledDelegate = self
                reConnectionFreqTask.startRepeatingTask()
            }
            
            // ì´ ë©”ì„œë“œëŠ” ì„œë²„ì— ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— ì±„ë„ì„ êµ¬ë…í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
            private func continueChannelSubscribe() {
                self.isChannelSubscribing = false
                
                // ì „ë¶€ êµ¬ë… ì·¨ì†Œ í›„ ì¬êµ¬ë…
                self.releaseAllChannels()
            
                self.unSubscribeFromChannels(channelName: "\(Config.passengerChannelName)")
                self.unSubscribeFromChannels(channelName: "\(Config.passengerChannelName)\(UserDefaults.iUserId)")
                
                self.subscribeToChannels(channelName: "\(Config.passengerChannelName)\(UserDefaults.iUserId)")
                
                listOfSubscribedList
                    .filter { $0.isEmpty == false }
                    .forEach {
                        self.subscribeToChannels(channelName: $0)
                    }
            }
            
            // ì†Œì¼“í†µì‹  ìˆ˜ì‹  : ì´ ë©”ì„œë“œëŠ” ì±„ë„ì„ êµ¬ë…í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. (Publish-Subscribe module)
            private func subscribeToChannels(channelName: String) {   // ì†Œìº£í†µì‹  ìˆ˜ì‹ 
                log.verbose("channelName = \(channelName)")
                
                if channelName.isEmpty {
                    return
                }
                
                if UserDefaults.iUserId.isEmpty {
                    resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                    resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                    resetUpdateFreqTask(&amp;self.subscribeTask)
                    
                    return
                }
                
                if channelName.isEmpty == false {
                    if listOfSubscribedList.contains(channelName) == false {
                        listOfSubscribedList += [channelName]
                    }
                    
                    if client.isConnected() == false {
                        return
                    }
                    
                    if isChannelSubscribing == true {
                        listOfNotSubscribedList += [channelName]
                        
                        return
                    }
                    
                    isChannelSubscribing = true
                    
                    // ìŠ¹ì¸ì„ ë°›ì•„ ìƒˆì±„ë„ì„ êµ¬ë…í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
                    client.subscribeAck(channelName: channelName, ack: {
                        [weak self] (channelName: String, error: AnyObject?, data: AnyObject?) in
                        guard let self = self else { return }
                        
                        self.isChannelSubscribing = false
                        
                        if (error is NSNull) == false {
                            log.verbose("ì†Œì¼“ í†µì‹  ì—ëŸ¬ ë°œìƒ : \(String(describing: error))")
                        } else {
                            // íŠ¹ì • ì±„ë„ êµ¬ë…ì— ì„±ê³µí•˜ë©´ í•´ë‹¹ ì±„ë„ì—ì„œ ì²­ì·¨ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
                            self.client.onChannel(channelName: channelName, ack: { (channelName: String, data: AnyObject?) in
                                // ì´ë²¤íŠ¸ ì•Œë¦¼ì´ ë„ì°©í•˜ë©´ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
                                let datas = JSON(data as Any)
                                let bodyStrig = datas.stringValue
                                let realBody = JSON(bodyStrig.getJsonDataDict())
                                log.verbose("ì†Œì¼“ í†µì‹  ì‘ë‹µê°’ : \(channelName) :: \(datas)")
                                
                                // PQ-1808 ì˜ˆì•½ì—¬ì •ì‹œ ë©”ì¸ì—ì„œ ë°›ì§€ ì•ŠëŠ” ê²½ìš°
                                if realBody["Message"].stringValue == TripStatusActive.cabRequestAccepted.rawValue ||
                                    realBody["MsgType"].stringValue == TripStatusActive.cabRequestAccepted.rawValue {
                                    
                                    if Config.mainLoadCheck == false {
                                        NotificationCenter.default.post(name: .reserveTripNoti, object: nil)
                                        return
                                    }
                                } else if (realBody["Message"].stringValue == TripStatusActive.reservedConfirm.rawValue) {
                                    
                                    self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                    NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                    return
                                } else if (realBody["Message"].stringValue == TripStatusActive.reservedFailed.rawValue) {
                                    
                                    self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                    NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                    return
                                } else if (realBody["Message"].stringValue == TripStatusActive.tripCancelledByDriver.rawValue) {
                                    // ì˜ˆì•½ í™•ì • í›„ ì·¨ì†Œí•˜ëŠ” ê²½ìš° TripCancelledByDriverë¡œ ë‚´ë ¤ì™€ì„œ ë©”ì¸í™”ë©´ ì•„ë‹Œ ê²½ìš° ì²˜ë¦¬
                                    if Config.mainLoadCheck == false {
                                        
                                        self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                        
                                        NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                        
                                        return
                                    }
                                }
                                
                                NotificationCenter.default.post(name: .updateTripStatusNoti, object: realBody)
                            })
                            
                            if self.listOfNotSubscribedList.isEmpty == false {
                                let newChannel = self.listOfNotSubscribedList[0]
                                self.listOfNotSubscribedList.remove(at: 0)
                                
                                if newChannel.isEmpty == false {
                                    self.subscribeToChannels(channelName: newChannel)
                                }
                            }
                        }
                    })
                }
            }
            
            // íŠ¹ì • ì±„ë„ì—ì„œ ì‚¬ìš©ìêµ¬ë…ì„ ì·¨ì†Œí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.
            private func unSubscribeFromChannels(channelName: String) {
                if channelName.isEmpty == false {
                    if listOfSubscribedList.contains(channelName) {
                        client.unsubscribeAck(channelName: channelName, ack: { [weak self] (channelName, error, data) in
                            guard let self = self else { return }
                            
                            if (error is NSNull) == false {
                                log.error("êµ¬ë… ì·¨ì†Œ ì¤‘ ì—ëŸ¬ ë°œìƒ")
                            } else {
                                if let index = self.listOfSubscribedList.firstIndex(of: channelName) {
                                    self.listOfSubscribedList.remove(at: index)
                                }
                            }
                        })
                    }
                }
            }
            
            // ëª¨ë“  ì±„ë„ êµ¬ë…ì„ ì·¨ì†Œí•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” ê¸°ëŠ¥ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì´ ì‘ì—…ì€ ì•±ì´ ì¢…ë£Œë  ë•Œ ìˆ˜í–‰ë©ë‹ˆë‹¤.
            private func releaseAllChannels() {
                listOfSubscribedList.forEach {
                    unSubscribeFromChannels(channelName: $0)
                }
            }
            
            private func resetDidEnterBackgroundNoti() {
                NotificationCenter
                    .default
                    .rx
                    .notification(.applicationDidBackgroundNoti)
                    .subscribe(onNext: { [weak self] (aNotification) in
                        guard let self = self else { return }
                        
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        self.client.disconnect()
                    })
                    .disposed(by: disposeBag)
            }
            
            private func resetWillResignActiveNoti() {
                NotificationCenter
                    .default
                    .rx
                    .notification(.applicationWillResignActiveNoti)
                    .subscribe(onNext: { [weak self] (aNotification) in
                        guard let self = self else { return }
                        
                        self.resetUpdateFreqTask(&amp;self.reConnectionFreqTask)
                        self.resetUpdateFreqTask(&amp;self.updateTripStatusFreqTask)
                        self.resetUpdateFreqTask(&amp;self.subscribeTask)
                        self.client.disconnect()
                    })
                    .disposed(by: disposeBag)
            }
            
            
            // ì—°ê²° ì•ˆë˜ì–´ìˆì„ ë•Œ HTTP ìš”ì²­
            // TODO: configPassengerTripStatus API message í‚¤ ê°’ íƒ€ì…ì´ ì •í™•íˆ ì˜¤ì§€ ì•Šì•„ì„œ ì†Œì¼“ ëŒ€ë¹„ì—ì„œë§Œ JSONì²˜ë¦¬
            private func requestConfigPassengerTripStatus() {
                if PlanConfig.currentLocation != nil {
                    Connection.configPassengerTripStatusJSON(vLatitude: "\(PlanConfig.currentLocation.coordinate.latitude)", vLongitude: "\(PlanConfig.currentLocation.coordinate.longitude)") { [weak self] (returnDatas, status) in
                        guard let self = self else { return }
                        
                        if status {
                            let dataDict = JSON(returnDatas as Any)
                            log.verbose("dataDict : \(dataDict)")
                            PlanConfig.vTripCancelConfirmMessage = dataDict["vTripCancelConfirmMessage"].stringValue
                            PlanConfig.vTripCancelDispatchTimeMessage = dataDict["vTripCancelDispatchTimeMessage"].stringValue
                            PlanConfig.vTripCancelFeesMessageConfirm = dataDict["vTripCancelFeesMessageConfirm"].stringValue
                            PlanConfig.vTripCancelFeesMessage = dataDict["vTripCancelFeesMessage"].stringValue
                            
                            let currentDrivers = dataDict["currentDrivers"].arrayValue
                            
                            if currentDrivers.isEmpty == false {
                                currentDrivers.forEach { value in
                                    let rowData = JSON(value)
                                    
                                    if PlanConfig.joinDriverId == rowData["iDriverId"].stringValue {
                                        PlanConfig.joinDriverLocation = CLLocation(latitude: rowData["vLatitude"].doubleValue, longitude: rowData["vLongitude"].doubleValue)
                                    }
                                    
                                    let bodyStrig = dataDict["message"].stringValue
                                    let realBody = JSON(bodyStrig.getJsonDataDict())
                                    log.verbose("configPassengerTripStatus í™•ì¸í•˜ê¸°A :: \(realBody)")
                                    
                                    // PQ-1808 ì˜ˆì•½ì—¬ì •ì‹œ ë©”ì¸ì—ì„œ ë°›ì§€ ì•ŠëŠ” ê²½ìš°
                                    if realBody["Message"].stringValue == TripStatusActive.cabRequestAccepted.rawValue ||
                                        realBody["MsgType"].stringValue == TripStatusActive.cabRequestAccepted.rawValue {
                                        
                                        if Config.mainLoadCheck == false {
                                            NotificationCenter.default.post(name: .reserveTripNoti, object: nil)
                                            return
                                        }
                                    } else if (realBody["Message"].stringValue == TripStatusActive.reservedConfirm.rawValue) {
                                        
                                        self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                        NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                        return
                                    } else if (realBody["Message"].stringValue == TripStatusActive.reservedFailed.rawValue) {
                                        
                                        self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                        NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                        return
                                    } else if (realBody["Message"].stringValue == TripStatusActive.tripCancelledByDriver.rawValue) {
                                        // ì˜ˆì•½ í™•ì • í›„ ì·¨ì†Œí•˜ëŠ” ê²½ìš° TripCancelledByDriverë¡œ ë‚´ë ¤ì™€ì„œ ë©”ì¸í™”ë©´ ì•„ë‹Œ ê²½ìš° ì²˜ë¦¬
                                        if Config.mainLoadCheck == false {
                                            
                                            self.openCommonPopup(message: realBody["vTitle"].stringValue)
                                            
                                            NotificationCenter.default.post(name: .resetTripListNoti, object: nil, userInfo: ["isRedDot": true])
                                            
                                            return
                                        }
                                    }
                                    
                                    NotificationCenter.default.post(name: .updateTripStatusNoti, object: realBody)
                                }
                            }
                        } else {
                            let dataDict = JSON(returnDatas as Any)
                            
                            if dataDict["message"].stringValue == "SESSION_OUT" {
                                log.verbose("SESSION_OUT_CALLED")
                                return
                            }
                        }
                    }
                }
            }
            
            // ì˜ˆì•½ í™•ì •, ì·¨ì†Œ ì•Œë¦¼ìš© ë©”ì„œë“œ
            private func openCommonPopup(message: String) {
                let mainStoryboard: UIStoryboard = UIStoryboard(name: "CommonPopupViewController", bundle: nil)
                let nextView = mainStoryboard.instantiateViewController(withIdentifier: "CommonPopupView") as! CommonPopupViewController
                let topView = Utillity.topViewController()
                
                if Utillity.isTypeViewController(type: CommonPopupViewController.self) {
                    topView?.dismiss(animated: true) {
                        let nextTopView = Utillity.topViewController()
                        nextView.titleString = "ì•Œë¦¼"
                        nextView.messageString = message
                        nextView.doneBtnString = "í™•ì¸"
                        
                        nextTopView?.present(nextView, animated: false)
                    }
                } else {
                    let nextTopView = Utillity.topViewController()
                    nextView.titleString = "ì•Œë¦¼"
                    nextView.messageString = message
                    nextView.doneBtnString = "í™•ì¸"
                    
                    nextTopView?.present(nextView, animated: false)
                }
            }
            
        }
        ```
        
    
    â†’ í˜„ì¬ëŠ” ì„œë²„ì— URLìš”ì²­í•˜ëŠ” APIí˜¸ì¶œì„ Launchí™”ë©´ì—ì„œ í˜¸ì¶œí•˜ëŠ”ë° í•­ìƒ ì‹±ê¸€í†¤ì¸ìŠ¤í„´ìŠ¤ìƒì„±ì‹œì ë³´ë‹¤ ë¨¼ì € í˜¸ì¶œì´ ë˜ëŠ” ê²ƒì¸ê°€?
    
    ì¼ë‹¨ ê¸°ë³¸ì ìœ¼ë¡œ Swiftì—ì„œ ì „ì—­ë³€ìˆ˜ë“¤ì€ ëª¨ë‘ lazyê°€ ê¸°ë³¸ì ìœ¼ë¡œ ì ìš©ëœ ìƒíƒœì´ë¯€ë¡œ lazyë¥¼ ì‚¬ìš©í•´ë„ ë˜‘ê°™ìŠµë‹ˆë‹¤ë‹¤. ì¦‰, ì‹±ê¸€í†¤ ê°ì²´ëŠ” ì‚¬ìš©ë˜ëŠ” ì‹œì ì— ë©”ëª¨ë¦¬ì— í• ë‹¹ë©ë‹ˆë‹¤.
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/000-first</guid><title>ì‚¬ìš©í•˜ê¸°</title><description>Tuist</description><link>https://sookim-1.github.io/posts/000-first</link><pubDate>Sat, 2 Dec 2023 09:00:00 +0000</pubDate><content:encoded><![CDATA[<p>TuistëŠ” XcodeGenê³¼ ë”ë¶ˆì–´ Xcode í”„ë¡œì íŠ¸ íŒŒì¼ì˜ ìƒì„±ë° ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ë„êµ¬(Command Line Tool) ì…ë‹ˆë‹¤.</p><p>XcodeGenì€ í”„ë¡œì íŠ¸ ì„¤ì •ì„ ymlì´ë‚˜ jsonìœ¼ë¡œ ê´€ë¦¬ í•˜ëŠ” ë°˜ë©´ì— TuistëŠ” Project.swiftë¼ëŠ” íŒŒì¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Project.swiftëŠ” ìŠ¤ìœ„í”„íŠ¸ì–¸ì–´ë¡œ ì‘ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.</p><p><a href="https://www.notion.so/Raywenderlich-Tuist-81f2114bd8724524a22e8367c23dfdba?pvs=21">Raywenderlich - Tuist ì •ë¦¬</a></p><h1>ì‚¬ìš©í•˜ê¸°</h1><ol><li>Tuist íˆ´ì„ ì„¤ì¹˜í•©ë‹ˆë‹¤.<ul><li><code>tuistenv</code> ë¼ê³  ìƒì„±ë˜ì–´ë„ ì¶”í›„ <code>tuist</code> ë¡œ ë³€ê²½ ì˜ˆì •ì´ë¼ê³  í•©ë‹ˆë‹¤.</li></ul></li></ol><pre><code class="language-swift">    $ curl -Ls https://install.tuist.io | bash
    ```
    

1. ë¹ˆ ë””ë ‰í† ë¦¬ë¥¼ ìƒì„±í•œ í›„ í•´ë‹¹ê²½ë¡œë¡œ ì´ë™í•˜ì—¬ í”„ë¡œì íŠ¸ ìƒì„±í•©ë‹ˆë‹¤.
    - í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ëŠ”ë° ì´ì „ì˜ SPMì„ ì‚¬ìš©í•œì ì´ ìˆë‹¤ë©´ `Package.swift` ì™€ `Project.swift` ëŠ”ë™ì¼í•©ë‹ˆë‹¤.
    
    ```swift
    # UIKit
    $ tuist init --platform ios
    
    # SwiftUI
    $ tuist init --platform ios --template swiftui
    ```
    

1. tree ëª…ë ¹ì–´ë¡œ íŒŒì¼ êµ¬ì¡° í™•ì¸ ê°€ëŠ¥í•©ë‹ˆë‹¤.
    
    ```swift
    # tree ì„¤ì¹˜
    $ brew install tree
    
    $ tree .
    ```
    
2. `Project.swift` ìˆ˜ì •í•˜ëŠ” ë°©ë²•
    
    ```swift
    $ tuist edit
    ```
    
3. ìœ„ì—ì„œ ì‘ì„±í•œ Project.swiftíŒŒì¼ì„ ê¸°ë°˜ìœ¼ë¡œ xcodeprojì™€ xcworkspaceë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    
    ```swift
    # ê¸°ë³¸ì ìœ¼ë¡œ ì˜ì¡´í•˜ëŠ” í”„ë¡œì íŠ¸ë¥¼ ëª¨ë‘ ìƒì„±í•©ë‹ˆë‹¤
    $ tuist generate
    
    # workspaceì˜ íŠ¹ì • í”„ë¡œì íŠ¸ë§Œ ìƒì„±í•˜ê³  ì‹¶ì€ ê²½ìš° ì˜µì…˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
    $ tuist generate --project-only
    ```
    
4. ì™¸ë¶€ Dependency ê°€ì ¸ì˜¤ê¸° (ì™¸ë¶€ë¼ì´ë¸ŒëŸ¬ë¦¬)
    
    ```swift
    $ tuist fetch
    ```
    

# ì°¸ê³ ë§í¬

- Tuist ê³µì‹ ì‚¬ì´íŠ¸ - https://tuist.io/
- Tuist ì‚¬ìš©ë°©ë²• (ê¹€ì¢…ê¶Œë‹˜ì˜ ë¸”ë¡œê·¸) - https://ios-development.tistory.com/m/1006
- Tuist íŠœí† ë¦¬ì–¼ (Raywenderlich) - https://www.raywenderlich.com/24508362-tuist-tutorial-for-xcode
- Tusit ë„ì…ê¸° (Yogiyo) - [https://techblog.yogiyo.co.kr/ios-í”„ë¡œì íŠ¸ì—-tuist-ì ìš©ê¸°-1d8f7d489252](https://techblog.yogiyo.co.kr/ios-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-tuist-%EC%A0%81%EC%9A%A9%EA%B8%B0-1d8f7d489252)
</code></pre>]]></content:encoded></item></channel></rss>