<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>sookim-1</title><description>Weekly Episodes</description><link>https://sookim-1.github.io</link><language>ko</language><lastBuildDate>Thu, 19 Sep 2024 06:24:34 +0000</lastBuildDate><pubDate>Thu, 19 Sep 2024 06:24:34 +0000</pubDate><ttl>250</ttl><atom:link href="https://sookim-1.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://sookim-1.github.io/posts/033-20240919</guid><title>번호 : 033, 작성일자: 2024-09-19</title><description>AVCaptureVideo 텍스트인식, 접근권한 사용시 주의사항, Xcode 버전별 차이점 정리, Xcode 단축키 정리, Youtube Playlist 스크립트 작성, SnapKit 애니메이션 처리, 정규표현식 Tip, SwiftUI - Kavsoft, 프로그래머스 코딩테스트</description><link>https://sookim-1.github.io/posts/033-20240919</link><pubDate>Thu, 19 Sep 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 033, 작성일자: 2024-09-19</h1><h2>2024.09.09 ~ 2024.09.18</h2><h3>📷 Text OCR</h3><hr><p>지난 주 YesWeScan라이브러리에서만 인식률이 좋았던 이유에 대해서 분석해본 결과 전달받은 AVCapturePhoto를 UIImage로 타입캐스팅한 결과 인식률이 좋지 않았고 CMSampleBufffer를 CIImage로 타입캐스팅하여 사용해야 인식률이 좋았다.</p><p>추가로 직접 캡처동작을 트리거하지 않고 매 프레임을 입력받아 자동으로 텍스트가 인식되면 처리하기 위해 고민해본 결과 AVCapturePhoto를 사용하지 않고 AVCaptureVideo를 사용하면 매 프레임을 입력받고 입력받은 CMSampleBuffer를 CIImage로 타입캐스팅 후 Vision을 통해 텍스트를 인식하게 되면 자동으로 텍스트가 인식된 경우를 처리할 수 있었다.</p><h3>🌎 Youtube Data API 활용 - 재생목록 내의 동영상목록 가져오기</h3><hr><p>지난 주 Youtube 특정채널 동영상목록을 가져오는 파이썬 스크립트를 작성했다.</p><p>특정채널 동영상목록이 매우 많은 경우 무료 API 제한량이 있어서 딜레이를 지정해도 모든 동영상을 가져오지 못하는 경우도 있고, 재생목록내의 동영상이 따로 있는 경우도 있어서 재생목록 내의 동영상목록을 가져오는 파이썬 스크립트를 추가작성했다.</p><p>🔗 <a href="https://developers.google.com/youtube/v3/docs/playlistItems/list?hl=ko">Youtube API Docs - playlistitem</a></p><pre><code class="language-python">import requests
import time

# Step 1: API 설정
API_KEY = ''  # 실제 API 키 작성
PLAYLIST_ID = '' # 재생목록 ID
CHANNEL_ID = ''  # 제목을 가져올 채널 ID

MAX_RESULTS = 50  # 한 번에 가져올 결과 수 (최대 50)

# 유튜브 데이터 API v3 playlistItems 엔드포인트 기본 URL
youtube_url = 'https://www.googleapis.com/youtube/v3/playlistItems'

# API 요청에 필요한 매개변수
params = {
    'part': 'snippet',
    'maxResults': MAX_RESULTS,
    'playlistId': PLAYLIST_ID,
    'key': API_KEY
}

# 재생목록에서 비디오 제목과 URL을 가져오는 함수
def fetch_playlist_video_titles_and_urls():
    videosResult = []
    next_page_token = None
    index = 1  # 동영상 인덱스 시작값

    while True:
        if next_page_token:
            params['pageToken'] = next_page_token

        # Step 2: 유튜브 데이터 API에 GET 요청 보내기
        response = requests.get(youtube_url, params=params)
        data = response.json()

        # Step 3: 비디오 제목 및 URL 추출
        for item in data['items']:
            title = item['snippet']['title']
            video_id = item['snippet']['resourceId']['videoId']
            video_url = f'https://www.youtube.com/watch?v={video_id}&amp;list={PLAYLIST_ID}&amp;index={index}'
            videosResult.append((title, video_url))
            index += 1

        # 다음 페이지가 있는지 확인
        next_page_token = data.get('nextPageToken')

        # 다음 페이지가 있을 경우, 61초 대기
        if not next_page_token:
            break

    return videosResult

# 제목과 URL을 텍스트 파일에 저장하는 함수
def save_titles_and_urls_to_file(videos, filename='playlist_video_titles_and_urls.txt'):
    with open(filename, 'w', encoding='utf-8') as file:
        for index, (title, url) in enumerate(videos, start=1):
            file.write(f"{index}. **[{title}]({url})**\n\n")

# 코드 실행
videos = fetch_playlist_video_titles_and_urls()
save_titles_and_urls_to_file(videos)
</code></pre><ul><li>원하는 채널ID를 검색한 후 다음페이지가 있다면 페이지를 검색하여 동영상목록을 가져온 후 playlist<em>video</em>titles<em>and</em>urls.txt파일에 저장하는 스크립트</li></ul><h3>👨‍🎓 AutorizationStatus 정리</h3><hr><p>iOS에서는 몇몇 시스템을 사용하기 위해서는 접근권한등이 필요합니다. 예를 들어, 위치권한이 필요한 경우 위치정보에 접근할 수 있는 권한이 필요합니다.</p><p>접근권한의 상태등을 알 수 있는 방법은 AuthorizationStatus라는 enum객체를 사용할 수 있습니다.</p><p>위치접근권한은 CLAuthorizationStatus로 case가 약간 다르지만 대부분의 case들의 종류는 3가지 (<code>Authorized</code> , <code>Denied</code> , <code>NotDetermined</code> )를 자주 사용합니다.</p><ul><li><code>Authorized</code> : 권한이 허용된 상태</li><li><code>Denied</code> : 권한이 거부된 상태</li><li><code>NotDetermined</code> : 권한허용여부를 물어보지 않은 상태</li></ul><p>그럼 notDetermined는 권한허용여부를 물어보지 않은 상태인데 앱이 처음 시작할 때 무조건 권한허용여부를 물어본 상태에도 가끔씩 notDetermined로 설정된 경우가 있을 수 있는 부분이 있어서 의아해서 검색해보았지만 오류가 발생할 수 있다는 내용만 찾았다.</p><p>권한요청을 하는 클로저내에서 UI관련 작업들은 메인스레드를 주의해서 사용할 필요가 있다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>Xcode 16이 발표되면서 이전 버전들의 차이점이 궁금해서 간단히 찾아보았는데 iOS보다 Xcode가 먼저 발표되었고 macOS전용이라는 부분등이 신기했다.</li><li>정규식 간단하게 사용하는 방법 <code>[A-Z0-91{2}_[A-Z0-9]{2}_[A-Z0-9]{2}</code> 와 <code>([A-Z0-9]{2}_){2}[A-Z0-9]{2}</code> 는 동일하다.</li><li>SnapKit으로 레이아웃을 구현하는 경우 키보드가 올라올 때 애니메이션 처리하는 방법<ul></ul></li></ol><pre><code class="language-swift">    @objc func keyboardWillShow(note: NSNotification) {
        if let keyboardSize = (note.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
            var keyboardHeight = CGFloat(Int(keyboardSize.height))
            
            self.scrollView.snp.updateConstraints {
                $0.bottom.equalToSuperView().offset(-keyboardHeight)
            }
    
            UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {
                self.view.layoutIfNeeded()
            }, completion: nil)
        }
    }
    ```
    
4. Xcode 단축키를 정리했다.
5. Kavsoft라는 SwiftUI를 잘 정리한 사이트가 있어서 해당 채널을 보며 정리했다.
6. 프로그래머스 코딩테스트 0단계 중 자주 사용하지 않았던 메서드들을 정리 했다.
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/032-20240909</guid><title>번호 : 032, 작성일자: 2024-09-09</title><description>SwiftUI + TCA 느낀점, URLComponent 사용시 주의사항, Youtube API 재생목록 가져오기, Vision프레임워크를 활용하여 Text 추출하기</description><link>https://sookim-1.github.io/posts/032-20240909</link><pubDate>Mon, 9 Sep 2024 19:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 032, 작성일자: 2024-09-09</h1><h2>2024.09.03 ~ 2024.09.08</h2><h3>🏬 SwiftUI + TCA (The Composable Architecture)</h3><hr><p>기존 UIKit 프로젝트에서 SwiftUI + TCA를 적용한 화면을 적용하기 위해 개발을 했다.</p><p>일단 SwiftUI를 사용하며 느끼는 점은 편리한 부분이 많다는 점이였다.</p><p>UIComponent를 분리 작업, SwiftUI 코드가 UIKit보다 코드 줄이 적어서 가독성이 좋았고, ChatGPT 활용도, Preview 속도등 UI 개발시간이 단축되는 느낌이다.</p><p>TCA는 API 처리 할 때 request, response등 Action이 2개 이상 추가해야해서 조건이 많지 않을 까 생각해봤는데 해당 아키텍처라이브러리에서 단방향을 지키기 위한 부분이라고 생각했다.</p><h3>📷 Text OCR</h3><hr><p>사진에서 Text를 추출하기 위해서 여러가지 Tool이 있다.(Google ML Kit, NHNCloud OCR, Vision)</p><p>그 중 Vision 프레임워크는 Apple에서 제공하는 프레임워크여서 해당 프레임워크를 사용해서 텍스트추출을 시도해봤다.</p><p>이름이 비슷한 VisionKit프레임워크도 있는데, 해당 프레임워크를 같이 사용하면 VNDocumentCameraViewController를 사용하여 영역을 인식해주고 이미지를 추출하면 Vision프레임워크를 이용해 해당 이미지에서 텍스트를 추출할 수 있다.</p><p>하지만, 카메라 스캔화면을 Custom하기 위해서는 직접 VNDocumentCameraViewController를 Custom하는 방법은 아직 없는 것 같다.</p><p>그래서 AVFoundation프레임워크를 활용하여 카메라를 캡처한후 이미지를 Vision프레임워크에 제공했는데 인식률이 현저히 떨어졌다.</p><p>VisionKit이 제공되지 않았을 때 자주 사용하던 🔗 <a href="https://github.com/adorsys/YesWeScan">YesWeScan라이브러리</a>가 있다고 해서 이미지를 제공하여 테스트해보았는데 VisionKit과 인식률이 동일했다.</p><p>해당 라이브러리를 분석하여 내가 첫번째로 사용했던 AVFoundation에서 설정하는 부분에서 차이점을 찾아보고 확인해봐야겠다.</p><h3>🌎 Youtube Data API 활용</h3><hr><p>개발과 관련된 유용한 Youtube채널의 영상들의 시청여부를 저장하기 위해 Youtube Data API를 활용해서 재생목록을 텍스트파일로 정리해주는 파이썬스크립트를 작성했다.</p><p>🔗 <a href="https://developers.google.com/youtube/v3/docs/search/list?hl=ko">Youtube API Docs - search</a></p><pre><code class="language-python">import requests
import time

# Step 1: API 설정
API_KEY = ''  # 실제 API 키 작성
CHANNEL_ID = ''  # 제목을 가져올 채널 ID

MAX_RESULTS = 50  # 한 번에 가져올 결과 수 (최대 50)

# 유튜브 데이터 API v3 검색 엔드포인트 기본 URL
youtube_url = 'https://www.googleapis.com/youtube/v3/search'

# API 요청에 필요한 매개변수
params = {
    'part': 'snippet',
    'maxResults': MAX_RESULTS,
    'channelId': CHANNEL_ID,
    'type': 'video',
    'order': 'date',  # 결과를 날짜순으로 정렬
    'key': API_KEY
}

# 비디오 제목과 URL을 가져오는 함수
def fetch_video_titles_and_urls():
    videosResult = []
    next_page_token = None

    while True:
        if next_page_token:
            params['pageToken'] = next_page_token

        # Step 2: 유튜브 데이터 API에 GET 요청 보내기
        response = requests.get(youtube_url, params=params)
        data = response.json()

        # Step 3: 비디오 제목 및 URL 추출
        for item in data['items']:
            title = item['snippet']['title']
            video_id = item['id']['videoId']
            video_url = f'https://www.youtube.com/watch?v={video_id}'
            videosResult.append((title, video_url))

        # 다음 페이지가 있는지 확인
        next_page_token = data.get('nextPageToken')

        # 다음 페이지가 있을 경우, 61초 대기
        if next_page_token:
            time.sleep(61)

        if not next_page_token:
            break

    return videosResult

# 제목과 URL을 텍스트 파일에 저장하는 함수
def save_titles_and_urls_to_file(videos, filename='video_titles_and_urls.txt'):
    with open(filename, 'w', encoding='utf-8') as file:
        for index, (title, url) in enumerate(videos, start=1):
            file.write(f"{index}. {title}\n- {url}\n\n")

# 코드 실행
videos = fetch_video_titles_and_urls()
save_titles_and_urls_to_file(videos)

</code></pre><ul><li>원하는 채널ID를 검색한 후 다음페이지가 있다면 페이지를 검색하여 동영상목록을 가져온 후 video<em>titles</em>and_urls.txt파일에 저장하는 스크립트</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>URLComponents에 queryItem에 추가하면 자동으로 UTF-8형식 URL인코딩을 자동으로 해주기 때문에 따로 처리하면 중복 인코딩이 될 수 있다.<ul></ul></li></ol><pre><code class="language-swift">        func requestSearch(keyword: String) async throws -&gt; Result&lt;SampleDTO, SampleError&gt; {
    				...
    				
            /* 중복
            guard let encodedKeyword = keyword.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
                return .failure(.invalidUrl)
            }
            */
    
            // query에 넣으면 자동으로 URL Encoding함
            components?.queryItems = [
                URLQueryItem(name: "searchKeyword", value: keyword)
            ]
            
            ...
    ```
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/031-20240903</guid><title>번호 : 031, 작성일자: 2024-09-03</title><description>TCA Tutorial 정리, Design Sytstem - Target 관리 및 쉘스크립트 작성, Tuist + Fastlane 이슈, UnitTest 의존성 주의사항</description><link>https://sookim-1.github.io/posts/031-20240903</link><pubDate>Tue, 3 Sep 2024 18:44:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 031, 작성일자: 2024-09-03</h1><h2>2024.08.27 ~ 2024.09.02</h2><h3>🏬 TCA (The Composable Architecture)</h3><hr><ul><li>🔗 <a href="https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/">pointfreeco - Tutorial</a></li></ul><p>해당 Tutorial은 TCA 라이브러리를 만든 pointfreeco에서 제공하는 Tutorial인데 처음 TCA를 시작하기 좋아서 정리하면서 사용방법에 대해서 알아보았다.</p><p>TCA는 아키텍처를 구현하는데 도움을 주는 라이브러리이기 때문에 라이브러리를 추가했다. 라이브러리를 설치한 후 빌드시간을 봤는데 매우 증가되었다. 일단 검색해본 결과 Apple 측에서 Swift Syntax 컴파일시간이 늘어나서 오래걸린다고 하는 것 같다.</p><p>TCA와 SwiftUI를 같이 사용하는 경우 View에 Store를 연결한 후 Action을 입력받아 State를 변경하는 방식이였다.</p><p>Action을 입력받아 State를 변경하는 객체는 Reducer 프로토콜을 준수하는 Feature에서 담당한다.</p><p>TCA를 배우면서 느낀점은 사실상 크게 보면 View와 Feature만 나눠져있어서 Feature가 MVC의 Controller나 MVVM의 ViewModel 처럼 무거워지지 않을까 생각했는데 Feature를 더 작게 나눈 후 통합하는 부분이 자연스러웠고 Swift Macro가 구현이 잘되어 있어서 일단 깔끔했던 것 같다.</p><p>그리고 Unit테스트를 진행할 때 Feature만 테스트를 진행하면 되고 TestStore를 비롯해 여러 테스트도구도 제공하기 때문에 테스트코드 작성이 매우 편리했다.</p><h3>🎨 Design System</h3><hr><p>개인적으로 사용하는 DesignSystem을 여러 Target으로 나누었을 때 비공개 Spec 저장소 하나에서 올리고 싶어서 SwiftUI Target을 추가했다.</p><p>라이브러리의 버전을 올릴 때 podspec파일들을 찾아서 version을 올려주는 쉘스크립트파일을 작성했고 해당 실행이 완료되면 workflow가 돌아서 tag 버전도 올리는 파일을 작성했지만 Linux에서 이슈가 있어서 일단 쉘스크립트파일에서 tag 버전까지 올리도록 임시로 설정했다.</p><h3>🚨 Tuist와 Fastlane을 사용할 때 관련된 이슈</h3><hr><p>전처리문 조건문에서 Build Configuration이 제대로 분기처리 되지 않는 이슈</p><ul><li>xcconfig파일에서 OTHER<em>SWIFT</em>FLAGS[config=Release]=$(inherited) -D RELEASE 처럼 조건부컴파일을 위한 플래그를 설정해주는 -D 플래그 설정이 되지 않았던 문제</li><li>-D 플래그에 설정한 문자열을 전처리문 조건문에서 사용할 수 있다.</li></ul><p>Tuist를 적용하면서 fastlane 배포 후 버전업데이트를 xcode프로젝트에만 적용해서 버전이 맞춰지지 않는 이슈</p><ul><li>fastlane에서 xcode프로젝트 버전업데이트 해주는 lane이 존재하지만 xcconfig도 변경해주기 위해서 🔗 <a href="https://github.com/sovcharenko/fastlane-plugin-xcconfig">fastlane-plugin-xcconfig</a>을 활용해서 Marketing Version, Current Project Version을 수정해주는 lane을 쉽게 작성할 수 있다.</li></ul><p>fastlane에서 get<em>build</em>number를 가져오지 못하는 이슈</p><ul><li>$ agvtool what-version를 실행할 때 불러오지 못하는 경우 Build Setting에서 Versioning System - AppleGeneric으로 변경한다.</li><li>변경해도 안되는 경우 버전을 변경하면 인식하는데 첫 xcode 프로젝트 생성할 때 인식을 못하면 Tuist에서 Setting할 때 Current Project Version을 1로 설정후 생성한다.</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>UnitTest를 SwiftPM사용하는 경우 본 Target을 추가하면 자동으로 의존성들이 같이 추가되기 때문에 CocoaPods처럼 Test 타겟에서 따로 설치할 필요가 없다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/030-20240827</guid><title>번호 : 030, 작성일자: 2024-08-27</title><description>Swifter앱 정리, Supabase Auth 적용, SwiftPM 블로그, .gitignore 리팩토링, 접근권한 AuthorizationStatus 관련 이슈, Crash - Zombie Object 검토, Github Action 검토</description><link>https://sookim-1.github.io/posts/030-20240827</link><pubDate>Tue, 27 Aug 2024 12:10:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 030, 작성일자: 2024-08-27</h1><h2>2024.08.19 ~ 2024.08.26</h2><h3>🎨 Swifter for SwiftUI 정리</h3><hr><ul><li>🔗 <a href="https://apps.apple.com/us/app/swifter-for-swiftui/id1621133381?l=ko">Swifter for SwiftUI</a></li></ul><p>Swifter for SwiftUI라는 SwiftUI를 개발할 때 SwiftUI의 Component 설명, 기본 사용법, Tip들을 간단하게 정리해놓은 앱을 보며 정리해봤다.</p><p>유료결제를 해야 모든 내용이 보여 결제 후 정리했다. OS 업데이트에 맞춰서 내용이 대응이 안되있는 부분들도 있지만 만족했다.</p><p>그리고 정리 후 이번 사이드프로젝트에 SwiftUI를 적용했다.</p><p>SwiftUI와 TCA아키텍처를 자주 사용하는 것 같아서 TCA와 관련된 링크들을 찾아봤다.</p><ol><li>🔗 <a href="https://gist.github.com/Achoo-kr/5d8936d12e71028fcc4a7c5e078ca038">pointfreeco -ReadMe Korean</a></li><li>🔗 <a href="https://www.pointfree.co/collections/composable-architecture">pointfreeco - 동영상 강의</a></li><li>🔗 <a href="https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/">pointfreeco - Tutorial</a></li><li>🔗 <a href="https://ridibooks.com/books/2773000087">TCA 한글 e-book</a></li></ol><h3>🔐 Supabase Auth</h3><hr><p>Firebase의 대항마로 최근 떠오르는 Supabase를 이번에 사이드프로젝트에 적용해보기로 했다.</p><p>기존에 FirebaseAuth + SwiftUI 로 로그인기능을 구현한 프로젝트가 있었는데 거의 바꿀 부분은 인스턴스만 변경하고 메서드가 거의 동일했다.</p><p>Supabase Auth에서 가장 큰 특징은 카카오 인증이 있는 부분이 신기했다.</p><p>사이드프로젝트에서 이메일로 회원가입, 로그인, 로그아웃까지 적용했다.</p><h3>📃 SwiftPM 관련 글 작성</h3><hr><p>🔗 <a href="https://sookim-1.tistory.com/entry/iOS-SwiftPM-SwiftPackage-1">SwiftPM - SwiftPackage</a></p><p>SwiftPackage, SwiftPM, SwiftPackage를 만드는 방법, 간단한 구조에 대한 설명을 작성했다.</p><p>🔗 <a href="https://sookim-1.tistory.com/entry/SwiftPM-PackageCollection">SwiftPM - PackageCollection</a> PackageCollection을 만들어 쉽게 Package목록을 추가하는 방법과 서명을 추가하는 방법에 대해 작성했다.</p><p>PackageCollection을 사용하는 방법에 대해서 WWDC 영상에 매우 친절하게 설명하지만, 서명을 추가하는 방법은 없어서 자세히 작성했다.</p><p>해당 글을 정리한 후, 직접 사용 중인 DesignSystem에 비공개로 SwiftPackage를 배포했다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>🔗 <a href="https://gist.github.com/sookim-1/a3f22fa6c8bee5120e4ecdf663f81f36">.gitignore의 스니펫</a>이 보기가 힘들어서 주석을 추가하여 정리했다.</li><li>iOS앱의 접근권한 중 카메라 권한을 변경하면 앱이 Refresh 되는 것 같다. (다른 접근권한들도 확인해봐야겠다.) 또한, 권한요청을 한 번 했어도 TestFlight에서 앱을 계속 다운로드 받다보면 가끔씩 🔗 <a href="https://developer.apple.com/documentation/corelocation/cllocationmanager/authorizationstatus-swift.property">AuthorizationStatus</a>가 notDetermined가 되는 경우가 있다.</li><li>Firebase Crashlytics에서 objc_retain이라는 이슈가 있어서 확인해보았는데 Zombie객체에 접근할 때 발생하는 이슈였다. 메모리가 해제되었는데 접근할 때 Crash가 발생한다고 한다. Xcode Instrument를 통해 확인해볼 수 있다는 데, 좀 더 봐야될 것 같다.</li><li>Github Action을 iOS앱개발자입장에서 어떻게 사용할 지 고민해봤다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/029-20240819</guid><title>번호 : 029, 작성일자: 2024-08-19</title><description>Tuist 기존프로젝트 적용, LinkedIn 업데이트 작성, Medium 코딩도우미 정리</description><link>https://sookim-1.github.io/posts/029-20240819</link><pubDate>Mon, 19 Aug 2024 19:40:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 029, 작성일자: 2024-08-19</h1><h2>2024.08.12 ~ 2024.08.18</h2><h3>⚙️ Tuist</h3><hr><p>기존프로젝트에 Tuist를 적용하기 위해서 준비할 파일들은 Default에서 변경된 값이 있다면 Info.plist, xcconfig 파일이 있다.</p><p>Info.plist를 추출하기 편리하게 하기 위해 Xcode Target - Build Setting - Generate info.plist File을 No로 설정한 후 Info탭에 존재하는 키값들을 Xcode Navigator영역에 존재하는 Info.plist로 옮겨주었다.</p><pre><code class="language-bash"># Target 빌드 셋팅 추출
$ tuist migration settings-to-xcconfig -p Project.xcodeproj -t MyApp -x MyApp.xcconfig

# 프로젝트 빌드 셋팅 추출
$ tuist migration settings-to-xcconfig -p Project.xcodeproj -x MyAppProject.xcconfig
</code></pre><p>해당 명령어를 통해 xcconfig파일을 추출했다.</p><ul><li>.gitignore에 <em>.xcodeproj, </em>.xcworkspace, Derived/ 를 추가한 후 Project.swift를 작성했다.</li><li>간단히, Tuist Project의 Sources와 Resources 매개변수는 각각 Compile Sources, Copy Bundle Resources에 추가되기 때문에 프로젝트의 파일분리가 잘되어있지 않은 경우, 와일드카드를 활용하여 해결할 수 있다.</li><li>파일이 삭제할 때 제대로 삭제되지 않은 경우, Xcode Navigator 영역에 표시되지 않는 미추적되는 파일들은 제외하거나 삭제해줘야 한다.</li><li>TargetScript를 작성할 때 script를 직접 작성하여 추가할 지, script파일을 만들어 연결을 시킬지는 각각 장단점이 있는 것 같다. script를 직접 작성하면 Xcode에서 바로 확인 할 수 있는 부분이 좋은 것 같지만 변경사항이 제대로 적용되지 않는 것 같다.<ul><li>Swift Package Plugin - Build Tool Plugin을 사용하는 경우 Tuist Target에서 Dependency 인자에 plugin을 추가해줄 수 있다.</li></ul></li></ul><p>의존성관리도구로 CocoaPods, Carthage를 사용하지 않고 프로젝트파일들이 Swift파일로 구성되어 있는 경우, 큰 어려움이 없이 Tuist를 적용할 수 있었다.</p><p>Tuist에 관련된 글을 작성한 블로그 글 중 해외와 국내 비중을 계산하면 국내 비중이 월등히 높은 것 같다. 또한, 몇몇 글 중 Tuist 관련 객체 초기화메서드를 Custom해서 사용하는 글들이 많았는 데, 중복되는 부분들을 반복해서 작성하지 않아서 좋은점도 있지만, 메서드를 확인하여 어떤 부분들을 변경했는 지 확인하는 부분들은 불편한 것 같다. 상황에 따라 유용한 방법을 사용해야 겠다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>링크드인에 🔗 <a href="[https://www.linkedin.com/posts/sookim1_개발블로그를-시작하려고-할-때-잘못된-정보를-공유하는-것에-대한-두려움-activity-7229460165526175744-Dyn-?utm_source=share&utm_medium=member_desktop](https://www.linkedin.com/posts/sookim1_%EA%B0%9C%EB%B0%9C%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A0%A4%EA%B3%A0-%ED%95%A0-%EB%95%8C-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B3%B5%EC%9C%A0%ED%95%98%EB%8A%94-%EA%B2%83%EC%97%90-%EB%8C%80%ED%95%9C-%EB%91%90%EB%A0%A4%EC%9B%80-activity-7229460165526175744-Dyn-?utm_source=share&utm_medium=member_desktop)">블로그 게시글에 잘못된 내용을 포함해도 되는이유</a>에 관한 업데이트를 작성했다.</li><li>🔗 <a href="https://www.youtube.com/@user-wi3bv5zr9g">코딩도우미 유튜브 채널</a>에 올라오는 Medium관련 글들 중 유용한 글들을 나의 Medium List에 추가했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/028-20240812</guid><title>번호 : 028, 작성일자: 2024-08-12</title><description>SwiftPM Migration 안정성 테스트(빌드시간 확인, 의존성관리도구 장단점비교), git clone mirror를 사용하여 Repository 이동하기, git-filter-repo, git author 일괄 변경, git lfs</description><link>https://sookim-1.github.io/posts/028-20240812</link><pubDate>Mon, 12 Aug 2024 23:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 028, 작성일자: 2024-08-12</h1><h2>2024.08.06 ~ 2024.08.11</h2><h3>⚙️ SwiftPM 안정성 테스트</h3><hr><p>지난 주 프로젝트의 의존성관리도구를 CocoaPods에서 SwiftPM으로 Migration을 모두 완료해서 새로운 문제가 없는지 안정성 테스트를 진행했다.</p><p>변경을 모두 완료한 뒤 실제로 적용을 고려하기 위해 의존성관리도구 별로 각각의 차이점을 한 번 더 정리를 해봤다.</p><p>iOS 프로젝트에서 의존성관리도구로는 보통 3가지(CocoaPods, Carthage, SwiftPM)를 사용한다.</p><p>일단 Carthage도 장단점을 비교했지만, 지원하지 않는 라이브러리가 많기 때문에 사용을 고려하는 부분에서는 제외했다.</p><p>CocoaPods의 장점이 SwiftPM이 처음 출시했을 때는 Dynamic, Static 라이브러리를 모두 지원하고, CocoaPods를 지원하는 라이브러리가 많고, 해당 정보들도 많은 장점들이 있었지만 현재 날짜 기준으로는 해당 장점들이 모두 없어진 것 같다.</p><p>SwiftPM은 또한 Swift언어에 Built-in 되어있어 따로 설치하지 않아도 되고 애플이 공식적으로 지원하는 등 여러가지 장점이 있는 것 같다. 예외로는 Swift언어가 아닌 라이브러리를 사용할 때 불편한 단점이 있어서 해당 부분은대체할 수 없이 CocoaPods를 사용해야 할 것 같다.</p><blockquote><p>빌드시간 확인</p></blockquote><p>CocoaPods에서 SwiftPM으로 Migration을 한 후 SwiftPM은 의존성을 체크하는 과정이 없어 빌드시간이 더 빠르다고 하여서 실제로 빌드시간을 각각 체크해보았다.</p><p>첫 빌드시간 과 재빌드시간을 모두 측정해보았다.</p><p>Terminal에서 빌드시간 측정</p><pre><code class="language-bash"># SwiftPM 빌드시간 측정
$ time xcodebuild build -project SwiftPMProject.xcodeproj -scheme SwiftPMProject

# CocoaPods 빌드시간 측정
$ time xcodebuild build -workspace PAPA.xcworkspace -scheme PAPA
</code></pre><p>Xcode에서 빌드시간 측정</p><pre><code class="language-bash">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES
</code></pre><p>하지만, 결과는 의외로 첫빌드, 재빌드 모두 유사했다. 오히려 CocoaPods가 빌드시간이 더 빠른 경우도 있었다.</p><p>🔗 <a href="https://medium.com/@golddol2003/cocoapods-vs-spm-ba7b7478236b">CocoaPods vs SPM</a> 글을 참고한 결과 SwiftPM이 CocoaPods보다 빌드시간이 느려질 수 도 있는 이유는 SwiftPM은 모든 의존성을 빌드를 수행하는데 복잡한 의존성 그래프인 경우 더 느려질 수도 있다고 한다.</p><h3>🏃 Git Repository 이동 &amp;&amp; Git Author 전체변경</h3><hr><p>Git을 사용할 때 Commit의 모든 변경내역을 포함하여 Repository를 간단하게 이동시키는 방법을 찾았다.</p><pre><code class="language-bash">$ git clone --mirror https://github.com/sookim-1/originalRepo.git

// .git 폴더가 생기는데 해당 폴더로 이동
$ cd originalRepo.git

$ git remote set-url origin https://github.com/sookim-1/newRepo.git

$ git push --mirror
</code></pre><p>주의사항은 Github에서는 한 파일당 100Mb가 넘는다면 git-lfs를 사용하여 업로드를 해야하는데 git-lfs란? 대용량 파일을 텍스트포인터로 대체하여 올리는 방식이다.</p><p>하지만 gif-lfs를 저장하는 Storage는 Github에서 무료요금제의 경우 20일당 1Gb로 제한되어있다. data-pack을 5달러로 구매하면 50Gb로 업그레이드 할 수 있다.</p><p>용량이 초과한 경우, 용량을 초과한 Repository를 제거해도 초기화되는데 시간이 조금 걸리는 것 같다. 이전에는 수동으로 요청해서 제거했었다고 하는데 자동화가 되면서 느려진 것일수도 있을 것 같다.</p><pre><code class="language-bash">$ git lfs install

// 원하는 파일들 lfs 추가 
$ git lfs migrate import --include="Large/*, *.zip" --everything

$ git push --mirror
</code></pre><blockquote><p>git-filter-repo</p></blockquote><p>git-filter-repo란? 편리하게 커밋 기록들을 필터링하고 수정하는데 도움을 주는 툴이다.</p><p>해당 툴을 사용하여 잘못된 author를 쉽게 일괄 변경할 수 있고 커밋별 제거할 파일들도 일괄로 제거할 수 있었다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>NHN Cloud, Naver Clova 각각 3rd-party 플랫폼의 사용량을 확인하는 방법에 대해서 알아보았다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/027-20240806</guid><title>번호 : 027, 작성일자: 2024-08-06</title><description>CocoaPods에서 SwiftPM으로 Migration, 이력서 피드백, 상용한글 2350자, Github gist, Bitbucket Snippet</description><link>https://sookim-1.github.io/posts/027-20240806</link><pubDate>Tue, 6 Aug 2024 06:35:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 027, 작성일자: 2024-08-06</h1><h2>2024.07.29 ~ 2024.08.05</h2><h3>⚙️ CocoaPods → SwiftPM</h3><hr><p>의존성관리도구로 CocoaPods을 사용 중인 프로젝인 경우 Tuist를 도입을 생각 중이라면 SwiftPM이 작업하기 수월하고 빌드시간단축도 되기 때문에 장점을 고려하면 Migration을 할 수 있다.</p><p>일단 CocoaPods에서 SwiftPM으로 전환한다면 프로젝트에서 설치된 Pod과 Product를 정리한다.</p><p>그리고 발생하는 몇몇 상황에 대비해야한다.</p><ol><li>Swift Package에 설치되는 의존성버전들이 충돌되는 경우<br></br>🔗 <a href="https://github.com/sacOO7/socketcluster-client-swift">socket-cluster</a> 라이브러리는 업데이트가 지속적으로 되지 않아서 내부 Test타겟에서 RxSwift버전이 낮아 라이브러리 설치가 되지않았다.<br></br>그래서 🔗 <a href="https://github.com/sookim-1/socketcluster-client-swift">Test타겟을 제거한 Repository</a>로 설치했다.</li></ol><ol start="2"><li>SwiftPM을 지원하지 않는 라이브러리가 있는 경우<br></br>🔗 <a href="https://github.com/navermaps/ios-map-sdk">NaverMap iOS SDK</a>는 SwiftPM을 지원하지 않아서 검색 도중 🔗 <a href="https://github.com/jaemyeong/NMapsMap">지원하는 Repository</a>로 설치했다.</li></ol><p>모든 Swift Package를 설치한 후 추후 작업을 위해 Package Collection을 생성했다.</p><p><strong><code>Package Collection</code></strong></p><p>Package Collection을 생성할 때 🔗<a href="https://developer.apple.com/videos/play/wwdc2021/10197/">WWDC</a>에 설명이 잘되어 있었지만 서명을 추가하는 부분이 복잡했다.</p><ol> 
   <li>Swift Package Collection Certificate를 발급한다.</li>  
   <li>키체인에 등록 후 개인키 .p12 파일을 .pem으로 openssl로 변환한다. (openssl이 1버전대라면 그대로 사용이가능하지만 3버전대라면 -legacy 옵션을 추가한다.)</li>  
   <li>중간인증서와 루트인증서와 함께 package-collection-sign 명령어를 실행한다.</li>
</ol><p><strong><code>SwiftPM Migration 작업 순서</code></strong></p><ol> 
   <li>CocoaPods, Pod 관련 파일들을 제거했다.</li>  
   <li>🔗 [R.Swift라이브러리](https://github.com/mac-cain13/R.swift)를 사용하는 경우 SwiftPM에서는 R.generated.swift를 적용하는 Build Script를 제거한 후 Swift Package Build Tool Plugin으로 변경했다.</li>  
   <li>Firebase Crashlytics dSym을 업로드하는 빌드스크립트를 SwiftPM에 맞도록 변경했다.</li>
   <li>Objective-C 라이브러리를 사용하지 않는 경우 Bridging-Header.h를 제거했다.</li>
   <li>License Plist 라이브러리를 설치한 SwiftPM으로 업데이트했다.</li>
</ol><h3>📃 이력서 피드백</h3><hr><p>작성한 이력서에 대해 동료에게 피드백을 받았다.</p><p><strong><code>정리</code></strong></p><ul><li>간단소개글 및 자기소개는 문장의 느낌으로 작성한다.</li><li>도메인을 이해한 사람만 아는 용어는 자제한다.</li><li>Udacity - Nano Degree 강의들은 도움이 된다.</li><li><code>개발자기술면접노트</code> 라는 최근 나온 도서가 도움이 된다.</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>Bitbucket은 Cloud와 DataCenter로 나누어지는데 Cloud는 SaaS 제품이고, DataCenter는 설치형제품이다. 각종 제공되는 기능이 다른 부분들이 있다.</li><li>상용한글은 2350자로 구성되어있다.</li><li>Github gist 같은 기능을 Bitbucket에도 Snippet이라고 있다. gist는 public으로 전환 후에는 secret으로 변경이 되지 않는다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/026-20240729</guid><title>번호 : 026, 작성일자: 2024-07-29</title><description>CocoaPod 정리, Notion 정리, IQKeyboardManager 7.0.3 버전 이슈</description><link>https://sookim-1.github.io/posts/026-20240729</link><pubDate>Mon, 29 Jul 2024 14:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 026, 작성일자: 2024-07-29</h1><h2>2024.07.22 ~ 2024.07.28</h2><h3>⚙️ CocoaPod 정리</h3><hr><p>지난주 CocoaPod Private Repo를 배포하는 방법에 대해서 정리를 했는데 해당 내용을 정리하면서 전체적으로 CocoaPod에 대해서 한번 더 정리해서 티스토리블로그에 단계별로 작성했다.</p><p>CocoaPod에 대한 설명, CocoaPod을 사용하면서 마주한 다양한 에러들과 자주 사용하는 명령어들, 라이브러리를 생성하고 공개 및 비공개로 배포하는 방법 등등을 정리했다.</p><ul><li>🔗 <a href="https://sookim-1.tistory.com/entry/iOS-CocoaPod-기본설명-1">CocoaPod 기본설명 - (1)</a></li><li>🔗 <a href="https://sookim-1.tistory.com/entry/iOS-CocoaPod-명령어-및-에러-정리-2">CocoaPod 명령어 및 에러 정리 - (2)</a></li><li>🔗 <a href="https://sookim-1.tistory.com/entry/iOS-CocoaPod-라이브러리-생성-및-배포하기-3">CocoaPod 라이브러리 생성 및 배포하기 - (3)</a></li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>개인 노션 페이지에 있는 iOS 개발 DB를 중복되는 페이지들은 정리하고 검색이 쉽도록 하나의 DB로 통합하는 과정을 60%정도 진행했다.</li><li>키보드입력이 감지되면 키보드높이만큼 View를 이동시키는 화면에서 이슈가 발생했는데 IQKeyboardManager 라이브러리를 7.0.3버전으로 업데이트하고 발생한 이슈여서 해당화면에서는 IQKeyboardManager를 비활성화했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/025-20240722</guid><title>번호 : 025, 작성일자: 2024-07-22</title><description>JSON 기본값 처리, CocoaPod 비공개저장소 배포, TabBar 멀티터치, WebView UserAgent</description><link>https://sookim-1.github.io/posts/025-20240722</link><pubDate>Mon, 22 Jul 2024 14:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 025, 작성일자: 2024-07-22</h1><h2>2024.07.15 ~ 2024.07.21</h2><h3>🌏 JSON 다루기</h3><hr><p>서버에서 응답받은 JSON의 Codable 모델을 작성했을 때, 키값의 자료형이 다르거나, 없는 키값이 있는 경우 앱이 종료되지 않도록 사전에 설정한 기본값으로 변경해주기 위해 KeyedDecodingContainer의 extension하여 사용할 수 있다.</p><p>하지만, 특정 요청에서는 null과 기본값을 구분해주고 싶은 경우에도 기본값으로 변경해주기 때문에 Decoder 객체에 구분할 수 있는 프로퍼티를 추가해주고 해당 프로퍼티값을 바라보면서 상황에 따라 구분할 수 있도록 코드를 수정했다.</p><p>해당 코드를 수정할 때 Mock API를 만들기 위해 🔗 <a href="https://insomnia.rest/"><strong>Insomnia</strong></a>툴을 사용했는데 매우 간편해서 자주 사용할 것 같다.</p><p>자주 사용할 수도 있다고 생각하여 🔗 <a href="https://gist.github.com/sookim-1/24118584ae49a5c1f5d11e03a4c50de9"><strong>KeyedDecodingContainer+Extension.swift</strong></a> 관련 코드를 gist에 추가했다.</p><h3>⚙️ private cocoapod 배포</h3><hr><p>SwiftUI프로젝트를 진행할 때 DesignSystem을 작성하여 사용하면 편리할 것 같아서 SwiftUI DesignSystem 저장소를 생성했다.</p><p>아직은 개인용도로 사용예정이여서 오픈소스로 배포하지 않고 private pod으로 배포하기 위해서 podspec을 수정하고 배포했다.</p><p>private pod으로 배포하기 위해서는 Library Repository와 Spec Repository를 2개를 생성해서 코드는 Library Repository에 작성하고 Spec Repository로 접근해서 Pod을 추가하는 원리였다.</p><p>공개저장소로 배포는 비공개저장소보다 더 간단했다. cocoaPod에 계정을 등록하고 podspec을 배포만하면 되었다.</p><p>적용은 잘되었지만, 아직 Resource파일의 번들을 찾지 못하는 문제들이 있지만, 보완해가면서 CocoaPod외에 SPM도 지원하도록 수정해가야겠다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>탭바 아이템 여러개를 동시에 터치했을 때 UITabBarControllerDelegate의 animation 처리하는 메서드에서 이슈가 발생했는데 기본적으로 탭바를 구현할 때 멀티터치를 제한하도록 해야겠다.</li><li>WebView 관련 코드리뷰 중 🔗 <a href="https://developer.apple.com/documentation/webkit/wkwebview/1414950-customuseragent"><strong>customAgent</strong></a>와 🔗 <a href="https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/1395665-applicationnameforuseragent"><strong>applicationNameForUserAgent</strong></a> 2가지를 설정하는 부분이 있어서 2개의 차이에 대해서 알아보았다. userAgent를 customAgent는 통째로 변경하고 applicationNameForUserAgent는 userAgent 끝에 추가하는 방식이였다. 하지만 applicationNameForUserAgent는 웹사이트에 따라서 값이 제대로 설정되지 않을 수 있어서 customAgent로 설정하는 방법이 안전한 방법 같다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/024-20240715</guid><title>번호 : 024, 작성일자: 2024-07-15</title><description>Github Blog 워크플로 이슈 수정, becomeFirstResponder 사용시 주의사항, git credential helper, Firebase Crashlytics 맞춤설정, Firebase TestLab, Swift Package 검토, iOS개발툴 신규 버전</description><link>https://sookim-1.github.io/posts/024-20240715</link><pubDate>Mon, 15 Jul 2024 15:20:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 024, 작성일자: 2024-07-15</h1><h2>2024.07.09 ~ 2024.07.14</h2><h3>🚨 Github-Blog 워크플로 수정</h3><hr><p>해당 블로그를 포스팅하는 🔗 <a href="https://github.com/sookim-1/blog-website"><strong>Github 블로그 저장소</strong></a>의 배포 관련에서 Github Workflow가 에러가 발생했다.</p><p>해당 저장소의 배포관련해서는 2가지 워크플로가 있다.</p><ol><li><code>ci.yml</code> : 빌드와 make 명령어가 정상적으로 되는지 확인하는 워크플로</li><li><code>deploy.yml</code> : 출력된 결과를 🔗 <a href="https://github.com/sookim-1/sookim-1.github.io"><strong>sookim-1.github.io 저장소</strong></a>로 덮어쓰는 워크플로</li></ol><p>해당 워크플로들을 수정하여 에러를 수정했다.</p><p>첫번째로는 워크플로를 동작하는 머신의 ubuntu버전이 node버전과 맞지 않았고, ubuntu 버전을 20.04로 올리면서 swift버전도 맞췄다. 또한 swift는 이미지로 설정했다.</p><p>2번째로는 배포되는 🔗 <a href="https://github.com/sookim-1/sookim-1.github.io"><strong>sookim-1.github.io 저장소</strong></a>에서 GoogleSearchConsole, Naver웹마스터도구의 html파일, robots.txt 파일이 덮어써지면서 제거되는 문제가 있어서 🔗 <a href="https://github.com/sookim-1/blog-website"><strong>Github 블로그 저장소</strong></a>에 파일을 옮긴 후 출력된 결과폴더에 추가되도록 수정했다.</p><p>3번째로는 중복된 단계가 많아서 결국 ci.yml과 deploy.yml은 연달아 동작하기 때문에 build-and-deploy.yml로 통합했다.</p><h3>⌨️ becomeFirstResponder</h3><hr><p>화면에 진입할 때 UITextField의 포커싱을 맞추기 위해서 viewWillAppear에 becomeFirstResponder를 실행했는데 viewWillAppear는 뷰가 완전히 로드되지 않은 상태여서 화면이 버벅이는 이슈가 있었다.</p><p>viewDidAppear에서 becomeFirstResponder를 실행하면 뷰가 완전히 로드된 후 호출되기 때문에 버벅이지는 않지만 약간의 속도가 느린 느낌이 들었다.</p><p>화면에 진입할 때 UINavigationController의 pushViewController 메서드의 애니메이션을 비활성화하니까 애니메이션처리가 생략되어 버벅이지 않았다.</p><p>여기서 애니메이션을 비활성화하고 비슷한 느낌을 주기위해서 화면전환하는 경우 커스텀애니메이션을 처리해서 해결했다.</p><pre><code class="language-swift">extension UINavigationController {
    func pushViewControllerCustomAnimation(_ vc: UIViewController) {
        let transition = CATransition()
        transition.duration = 0.3
        transition.type = CATransitionType.push
        transition.subtype = CATransitionSubtype.fromRight
        transition.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)
        
        view.layer.add(transition, forKey: kCATransition)
        pushViewController(vc, animated: false)
    }

    func popViewControllerCustomAnimation(completion: @escaping () -&gt; Void) {
        let transition = CATransition()
        transition.duration = 0.3
        transition.type = CATransitionType.push
        transition.subtype = CATransitionSubtype.fromLeft
        transition.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.easeInEaseOut)

        view.layer.add(transition, forKey: kCATransition)
        popViewController(animated: false, completion: completion)
    }
}
</code></pre><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>git credential osxkeychain이 접근할 때마다 팝업이 발생해서 .gitconfig파일에 <code>[credential] helper = osxkeychain</code>를 추가했다. $ git config --global credential.helper osxkeychain</li><li>Firebase Crashlytics의 맞춤설정방법, Firebase TestLab 제품들에 대해서 찾아보고 테스트를 해보았다.</li><li>Swift Package, SPM의 개념과 프로젝트생성방법을 정리했다. 추후 구조에 대해서 추가해야겠다.</li><li>Xcode 16, Swift 6, SF Symbol 6, macOS Sequoia 주요 변경사항들을 간단히 보았는데 정식버전이 출시되면 바로 업그레이드 하는 것도 고려해봐야겠다.</li><li>앱스토어커넥트의 접근계정을 정리했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/023-20240709</guid><title>번호 : 023, 작성일자: 2024-07-09</title><description>OCR을 통한 카드 스캔 기능, Skip을 활용하여 멀티플랫폼 앱개발, Design System 개발, 애니메이션 사용시 ViewController 생명주기 주의, Github Action 수정, UIView.Invalidating</description><link>https://sookim-1.github.io/posts/023-20240709</link><pubDate>Tue, 9 Jul 2024 12:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 023, 작성일자: 2024-07-09</h1><h2>2024.07.02 ~ 2024.07.08</h2><h3>🪪 OCR 검토</h3><hr><p>실서비스에서 카드등록을 하는 경우 직접 입력을 할 수 있지만, 사용자의 편의성을 위해 카드 스캔 기능을 지원하기도 한다.</p><p>해당 스캔 기능의 원리는 이미지에서 텍스트를 추출하여 가져오는 것이다.</p><p>Apple에서는 자체 프레임워크인 Vision, VisionKit 프레임워크를 제공하는데 해당 프레임워크들을 사용하여 이미지에서 텍스트를 추출할 수 있다.</p><p>사용해보았는데, 현대카드처럼 세로방식의 카드에서 인식을 하지 못하고, 인식률이 높지도 않아서 다른 OCR라이브러리를 검토 중 NHN에서 CreditCardOCR을 제공해서 시도해보았는데 인식률이 좋은 것 같다.</p><p>해당 라이브러리를 사용 중 카드를 인식하는 ViewController의 Property Naming오타가 있어서 🔗<a href="https://github.com/nhn/nhncloud.ios.sdk/pull/5"><strong>PR</strong></a>을 올렸다.</p><h3>🚀 Skip</h3><hr><p>모바일앱시장은 대표적으로 안드로이드와 iOS 두가지 OS가 인기가 있다.</p><p>따라서, 한 가지만 지원하는 것은 다른 OS의 사용자들을 포기해야 하는데 크로스플랫폼개발을 하게 되면 두가지 OS를 지원하는 것이 편리하다.</p><p>Flutter, React Native 등등 여러가지 크로스플랫폼개발이 있지만, 최근에 KMP라고 코틀린으로 개발할 수 있는 기술이 생겼다. 이와 비슷한 기술로 🔗 <a href="https://skip.tools/"><strong>Skip</strong></a>은 Swift로 개발을 할 수 있는 기술이여서 찾아보았다.</p><p>아직 1.0이 발표되지 않았고 개발 진행 중이여서 무료로 지원해서 써보았다.</p><p>구현원리는 Swift코드를 빌드하면 Kotlin코드로 변환해주고 SwiftUI는 Compose로 변환해준 후 컴파일하기 때문에 진정한 Native로 변환해주는 원리다.</p><p>Swift언어와 SwiftUI를 사용해야 하고, 기존 프로젝트를 migrate하는 방법은 권장하지 않고 새로운 Skip프로젝트를 생성하여 개발하는 방법을 권장하고 있었다.</p><p>Firebase나 Third-party Library를 사용할 때 굉장히 불편하고, 타입추론 부분에서 많은 에러가 발생했다. 아직은 실서비스에서는 사용하기 어렵고 간단한 앱에서만 가능할 것 같다.</p><p>사용방법은 굉장히 간단했다.</p><ol><li>Skip 설치 - $brew install skiptools/skip/skip</li><li>Skip 실행가능여부 확인 - skip checkup</li><li>Skip 프로젝트 생성 - skip init --appid=bundle.id project-name AppName</li></ol><p>생성된 프로젝트의 ContentView부터 작업을 진행하면 된다.</p><h3>🌈 Design System</h3><hr><p>디자인시스템은 디자이너와 소프트웨어 엔지니어가 UI구현 작업속도를 높이기 위해 재사용 가능한 구성요소, 토큰 및 기타 디자인 표준의 모음인데 기존에 커스텀뷰를 사용하는 것을 좀 더 통일화시키기 위해 DS개발을 진행했다.</p><p>진행하기 전에 어떤 식으로 구현을 해야 재사용성이 높을지에 대해서 참고하기 위해 다른 DS를 찾아보았다.</p><p>가장 참고하기 좋았던 DS들은 Skyscanner의 DS와 숭실대 동아리 DS였다. 해당 오픈소스들은 샘플도 제공하고 숭실대 동아리 DS는 피그마도 제공했다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>viewDidAppear에서 애니메이션처리를 하였는데 애니메이션 시작이 약간 지역되어 화면이 버벅였다. viewDidAppear는 뷰가 화면에 완전히 표시된 후 호출되기 때문에 viewWillAppear에서 애니메이션처리를 하고 해결되었다.</li><li>Github Blog를 올리는 workflow를 일부 수정하였다. 문서형식을 action을 시작할 때 더 받은 값을 받아서 자동화하도록 추가했다.</li><li>뷰가 변경될 때마다 유용한 프로퍼티래퍼를 찾았는데 🔗<a href="https://developer.apple.com/documentation/uikit/uiview/invalidating"><strong>UIView.Invalidating</strong></a>이다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/022-20240702</guid><title>번호 : 022, 작성일자: 2024-07-02</title><description>Fastlane Plugin Badge 활용, Xcode 실기기 인식오류, JD 정리, Flex Layout &amp; Pin Layout 라이브러리, 서비스 메인 로직 ViewModel, 딥링크 활용시 Tip</description><link>https://sookim-1.github.io/posts/022-20240702</link><pubDate>Tue, 2 Jul 2024 17:18:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 022, 작성일자: 2024-07-02</h1><h2>2024.06.24 ~ 2024.07.01</h2><h3>🚀 Fastlane Plugin - Badge 추가</h3><hr><p>Testflight에 업로드하는 경우 Build Configuration별로 쉽게 구분하기 위한 방법을 생각하던 중 테스트메모사항에 작성하여 구분하면 되겠다고 생각했다. upload<em>to</em>testflight 액션에서 changelog에 값을 제공하면 메모사항이 작성되지만 앱스토어커넥트에 앱이 업로드 된 후에 작성이 되기때문에 skip<em>waiting</em>for<em>build</em>processing를 사용할 수 없었다.</p><p>그래서 차선책으로 앱아이콘에 Badge를 표시하여 구분하는 방법을 찾았고 fastlane plugin을 활용하여 표시를 하여 구분이 편리하도록 했다.</p><p>구현방법에 대해서는 블로그글 <a href="https://sookim-1.tistory.com/entry/iOS-Fastlane-Plugin%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%B1%EC%95%84%EC%9D%B4%EC%BD%98-Badge-%ED%91%9C%EC%8B%9C">Fastlane Plugin을 활용하여 앱아이콘 Badge표시</a> 에서 자세히 작성해두었다.</p><h3>🚨 Xcode 실기기 인식오류</h3><hr><p>Xcode에서 실기기를 연결하는데 이전에 인식을 잘하다가 갑자기 인식을 못하는 이슈가 발생했다.</p><p>그래서 해결방법들에 대해서 찾아보았다.</p><ol><li>설정 → 일반 → 전송 또는 iPhone 재설정 → 재설정 → 위치 및 개인정보 보호 재설정</li><li>Xcode 재부팅 또는 기기 재부팅</li><li>Usb 케이블 제거 후 재연결</li><li>설정 → 개발자 → 신뢰하는 컴퓨터 지우기</li><li>터미널에서 <code>sudo pkill usbmuxd</code> 또는 <code>sudo launchctl stop com.apple.usbmuxd</code> 실행</li></ol><p>위의 여러가지 방법들을 직접 시도해보았지만 결국에는 Usb케이블이 문제였다. iPhone14Pro에서는 Usb연결을 인식해서 Usb케이블에서 문제가 있다고 생각을 못했었는데 iPhon XS Max에서만 안되었던 것이여서 다음부터는 기기별로 Usb케이블에 문제가 있을 수도 있으므로 다른 USB 케이블로 시도해봐야겠다.</p><p>→ 결론 : Usb 케이블로 인해서 Xcode에서 기기인식을 못할 수 있다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>JD(Job Description)에 대한 용어를 알게되었는데 정리를 해봐야겠다.</li><li>Flex Layout, Pin Layout이 요즘 자주 보여서 보았는데 Auto layout보다 성능이 뛰어나다고 해서 더 자세히 알아봐야겠다.</li><li>원링크 또는 딥링크를 구현할 때 화면계층이 너무 깊은 곳에서 다른 화면으로 전환해야 할 때는 window를 변경하는 방법이 전환속도와 애니메이션이 더 빠르고 부드러운 것 같다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/021-20240624</guid><title>번호 : 021, 작성일자: 2024-06-24</title><description>사이드프로젝트 보완, 개발에 도움이 되는 서비스, FCM HTTPv1 Migration</description><link>https://sookim-1.github.io/posts/021-20240624</link><pubDate>Mon, 24 Jun 2024 16:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 021, 작성일자: 2024-06-24</h1><h2>2024.06.17 ~ 2024.06.23</h2><h3>🚀 사이드프로젝트 보완(덕후감)</h3><hr><p>사이드프로젝트의 이름은 덕후감인데 애니메이션을 검색하여 현재 몇화까지 보았는지 저장하는 서비스 - <a href="https://github.com/sookim-1/Geek_Report">Geek_Report</a></p><ul><li>로그의 단계와 어느 파일, 라인 수를 확인할 수 있는 CustomLogger를 작성했다.</li><li>로딩을 표시하도록 CustomLoader를 작성했다.</li><li>CoreData로 저장하는 로직을 보완했다.<ul><li>중복데이터를 저장할 때는 업데이트를 하도록 수정</li><li>앱 충돌이슈 수정</li><li>CleanArchitecture + MVVM</li><li>일부 적용안된 부분을 적용해서 전체프로젝트에서 패턴 적용</li><li>API 호출 순서도 변경</li><li>Jikan API는 1초당 3개의 요청만 가능하므로 순서 변경하여서 모든 요청가능하도록 수정</li><li>실패한 경우 방어로직 추가</li><li>앱 아이콘 변경</li><li>Dall-E로 아이콘 생성</li></ul></li></ul><h3>⚙️ 개발에 도움이 되는 서비스</h3><hr><p>ChatGPT Plus를 결제했다. 비용이 비쌌지만 GPT-4모델을 사용할 수 있다는 점하고 GPTs(맞춤형GPT), Dall-E 이미지생성도 가능했다. GPTs를 검색해서 아이콘 전용 생성GPT에서 사이드프로젝트의 앱아이콘을 생성해보았는데 매우 만족스러웠다. GPTs는 여러 사람들이 생성한 모델을 검색하여 사용할 수도 있고 직접 구성하여 사용할 수도 있다.</p><p>Medium을 살펴볼 때 유료사용자에게만 글을 읽을 수 있는 권한을 주는 글들이 일부 있는데 프로모션으로 20프로할인이 진행 중이여서 1년을 결제했다. 양질의 글들이 많아서 자주 살펴봐야겠다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>FCM서비스가 2024년 6월 20일을 기점으로 레거시(XMPP, HTTP)방식의 통신 API를 중단하고, 새로운 HTTP v1 API를 지원하여서 마이그레이션을 진행한 후 영향도를 확인했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/020-20240617</guid><title>번호 : 020, 작성일자: 2024-06-17</title><description>Firebase 버전 이슈, open메서드 사용시 주의사항, ViewController 생명주기 수동 호출, HTML Entities 처리</description><link>https://sookim-1.github.io/posts/020-20240617</link><pubDate>Mon, 17 Jun 2024 18:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 020, 작성일자: 2024-06-17</h1><h2>2024.06.10 ~ 2024.06.16</h2><h3>⬆️ Firebase 버전 이슈</h3><hr><p>Build Configuration이 다른 환경에서만 이슈(Release 환경에서만 메인스레드 간섭이 일어나듯이 UI업데이트가 느린 이슈)가 발생하는 경우 각 Build Configuration별로 차이점을 찾아보았다. 지지난주 찾았던 차이점 중 하나는 "API 응답속도에서 차이가 있다."였고 또 발견한 다른 차이점은 로그성 라이브러리들의 차이도 있었다. 로그성 라이브러리들을 하나씩 찾아본 결과 FirebaseAnalytics의 사용여부에 따라 영향도가 있었다.</p><p>그래서 확인해본 결과 최근 FirebaseAnalytics 버전을 10.19.0에서 10.27.0으로 업그레이드를 진행했었다.</p><p>다시 10.19.0으로 다운그레이드를 하여 테스트한 결과 버전이슈로 판명하고 변경했다.</p><p>FirebaseAnalytics는 단독으로 다운그레이드가 되지않기 때문에 의존성을 갖는 제품들도 다운그레이드를 진행했다. 추가로, FireStore를 Binary로 설치시 FireStoreSwift가 같이 설치되지 않을 수 있다.</p><p>3rd-party 라이브러리의 버전변경은 항상 주의해야겠다.</p><h3>🚀 open(_:options:completionHandler:) 메서드</h3><hr><p>앱에서 링크를 간편하게 이동시키고 싶은 경우 <a href="https://developer.apple.com/documentation/uikit/uiapplication/1648685-open">open(_:options:completionHandler:)</a> 메서드를 사용할 수 있는데 외부 URL 이동할 때 앱으로 돌아온 경우 뷰의 터치이벤트를 전달받지 못할 수 있다.</p><p>뷰컨트롤러의 생명주기도 호출되지 않기 때문에 해결방법으로 completionHandler의 클로저에서 뷰커트롤러의 appearance 전환을 수동으로 처리했다.</p><pre><code class="language-swift">DispatchQueue.main.async {
    if let window = Application.window,
       let rootViewController = window.rootViewController {
        rootViewController.setNeedsLayout()
        rootViewController.layoutIfNeeded()
    }
}
</code></pre><ul><li><code>beginAppearanceTransition(_:animated:)</code>은 뷰가 화면에 나타나기 시작할 때 호출</li><li><code>endAppearanceTransition()</code>은 전환이 완료될 때 호출<ul><li>이 메서드들을 사용하면 뷰 컨트롤러의 생명 주기 이벤트 (<code>viewWillAppear</code>, <code>viewDidAppear</code>, <code>viewWillDisappear</code>, <code>viewDidDisappear</code>)가 올바르게 호출된다.</li></ul></li></ul><h3>🔠 HTML Entities</h3><hr><p>HTML 문자열을 화면에 표시하기 위해 태그처리를 진행했는데 태그 이외에도 Entities처리도 진행해야 했다.</p><p>HTML 문자열을 UILabel에 표시해야 했기 때문에 치환하는 방법을 생각했다.</p><p>HTML Entities는 특정 문자를 HTML에서 안전하게 표현하기 위한 코드나 식별자인데 모든 Entities를 치환하는 코드를 작성하려다가 <a href="https://github.com/Kitura/swift-html-entities">swift-html-entities</a> 라이브러리가 있어서 해당 라이브러리를 사용했다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>AppStore Connect에서 앱을 여러 버전을 출시대기중이 가능한지 확인해보았는데 이미 제출한 버전과 심사요청할 수 있는 버전 2개 버전만 관리할 수 있다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/019-20240610</guid><title>번호 : 019, 작성일자: 2024-06-10</title><description>AppIcon 변경, Throttle 중복처리 이슈</description><link>https://sookim-1.github.io/posts/019-20240610</link><pubDate>Mon, 10 Jun 2024 18:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 019, 작성일자: 2024-06-10</h1><h2>2024.06.03 ~ 2024.06.09</h2><h3>✅ Throttle 이벤트 중복처리 이슈</h3><hr><p>Build Configuration이 다른 환경에서만 이슈가 발생하는 경우 각 Build Configuration별로 차이점을 찾아보았다. 차이점 중 하나는 API 응답속도에서 차이가 있다. Release 환경에서 응답속도가 더 빠르다.</p><p>버튼을 클릭할 때 API요청을 한 후 성공한 경우에 화면전환을 하게 되는데 중복터치를 제한하기 위해 Throttle 처리를 하였다. Debug환경에서는 API 응답속도가 Live버전보다 느리기 때문에 1초로 설정하였을 때 이슈가 발생하지 않았지만 Release환경에서는 API응답속도 빠르게 와서 API응답이 오기전에 이벤트가 한 번더 들어가서 화면의 메모리가 쌓이는 이슈로 파악했다.</p><p>API요청을 다음화면에서 하도록 변경하였고, Indicator처리도 추가하여서 해결했지만, Throttle과 API요청을 함께 사용할 때 주의할점에 대해서 더 분석해봐야겠다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>타겟별로 빌드셋팅에서 ASSETCATALOG<em>COMPILER</em>APPICON_NAME을 변경하면 꼭 앱아이콘명을 AppIcon을 사용하지 않고 변경할 수 있다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/018-20240603</guid><title>번호 : 018, 작성일자: 2024-06-03</title><description>네이버지도 moveCamera 클로저, 성과 및 업무계획 정리, 링크드인 게시글 작성, Gemini Advanced 사용 경험, Slack WorkSpace 계정 비활성화</description><link>https://sookim-1.github.io/posts/018-20240603</link><pubDate>Mon, 3 Jun 2024 18:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 018, 작성일자: 2024-06-03</h1><h2>2024.05.27 ~ 2024.06.02</h2><h3>✅ 메모리 누수처리</h3><hr><p>메모리 누수가 발생하면 여러가지 이슈가 발생할 수 있다. 네이버지도 iOS SDK를 사용하는 경우 moveCamera 메서드에서 completion을 사용하는 경우 약한 참조 처리를 하지 않으면 메모리 누수가 발생한다. 네이버지도 iOS SDK를 사용할 때 moveCamera 메서드는 자주 사용하므로 인지하고 개발해야겠다.</p><h3>🌈 회고 및 업무계획서 작성</h3><hr><p>지난 주에 이어서 회고를 정리했다.</p><p>이번에는 만으로 경력 2년이 되어서 회사에서 했던 성과를 Confluence 문서와 Jira티켓, Bitbucket Commit등을 보면서 정리하였고 작년과도 비교해보았다. 작년에는 주로 프로젝트의 기반을 다지는 작업이 주였고, 해당년도부터는 실제 작업위주로 많이 진행했다.</p><p>처음 왔을 때는 InterfaceBuilder를 자주 사용해보지 않아서 사용경험을 향상 시킬 수 있어서 좋았고 Code-Based UI로 변경하면서 장단점에 대해 직접 느껴보았다.</p><p>성과를 정리한 후, 향 후 업무계획에 대해서도 정리하였다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>링크드인에 첫 게시글을 작성했는데 기존 프로필노출수보다 업데이트노출수 상승폭이 매우 큰 것 같다.</li><li>Gemini Advanced가 출시되어 경험해봤는데 속도가 빠른 느낌이였다. GPT-4와 비교한 글들이 많았는 데 무엇이 무조건 뛰어나다라는 느낌보다는 개개인별로 차이점을 제시한 느낌이여서 사용해봐야 할 것 같다.</li><li>Slack WorkSpace를 정리하였는데 Slack에서는 직접 만든 WorkSpace가 아니면 계정을 비활성화할 수는 있는데 탈퇴는 진행하지 못하는 것 같다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/017-20240527</guid><title>번호 : 017, 작성일자: 2024-05-27</title><description>작업 요약서 작성, FSCalendar</description><link>https://sookim-1.github.io/posts/017-20240527</link><pubDate>Mon, 27 May 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 017, 작성일자: 2024-05-27</h1><h2>2024.05.20 ~ 2024.05.26</h2><h3>📗 작업 요약서 작성</h3><hr><p>2022년 5월부터 현재까지 회사에서 작업했던 내용을 더 자세하게 요약하고 정리했다.</p><p>느낀 점은 처음에는 협업툴과 개발문화에 대해서 집중한 부분이 보였고, 도메인을 이해하고 나서부터는 신규기능과 이슈를 병행하여 수정해갔고, 그 외 시간에서는 리팩토링을 진행해왔던 것 같다.</p><h3>📅 FSCalendar</h3><hr><p>FSCalendar라이브러리를 사용한다면 FSCalendarDelegate의 메서드들을 알고 대략적으로 알아야겠다고 판단해서 직접 여러가지 시도를 하며 커스텀을 해보았다.</p><p>FSCalendar는 몇 가지 주의사항만 알게되면 사용방법이 매우 간단한 라이브러리 같다.</p><p>따라서 자주 사용하는 메서드들만 정리해두면 될 것 같아서 블로그에 예제코드를 작성했다.</p><ul><li><a href="https://sookim-1.tistory.com/entry/iOS-FSCalendar">FSCalendar 라이브러리 - sookim-1’s tistory</a></li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>GeekReport 사이드프로젝트의 (Clean Architecture + MVVM 을 부분 적용, Tuist 도입) 리팩토링을 진행했다. ReadMe도 업데이트해서 리팩토링을 1차는 완성된 것 같다.</li><li>UICollectionViewFlowLayout에서 UICollectionViewCompositional Layout으로 변경하면 코드 라인 수가 줄어들어 가독성이 향상되는 것을 직접 느꼈다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/016-20240520</guid><title>번호 : 016, 작성일자: 2024-05-20</title><description>Socket Cluster, Clean Architecture 패턴, Tuist 적용</description><link>https://sookim-1.github.io/posts/016-20240520</link><pubDate>Mon, 20 May 2024 12:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 016, 작성일자: 2024-05-20</h1><h2>2024.05.13 ~ 2024.05.19</h2><h3>🚨 Socket Cluster</h3><hr><p>Socket Cluster란 Socket 통신을 지원해주는 iOS 라이브러리다. 해당 라이브러리는 PubSub기능을 지원한다. iOS앱에서는 백그라운드로 이동하는 경우 Socket연결을 보장하지 않기 때문에 해제하는 것을 권장한다. 그러므로, 다시 Active상태가 되었을 때 Socket연결을 시도한다. 이런 운영체제의 환경으로 인하여, 재연결을 시도할 때 수신하지 못한 메시지가 전달되지 않거나 앱의 특정상태에서는 백그라운드에서도 Socket연결을 해제하지 않아야하는데 해제되는 경우를 대비해야 한다.</p><ol><li>SocketCluster에서 지원하는 setBackgroundQueue메서드를 이용하여 메인스레드에 영향을 주지않도록 변경했다.</li><li>재연결시도하는 Timer를 시작할때 재연결이 완료되기 전까지의 시간에 대응하기 위해 다른 HTTP를 호출하여 대응했다. 또한, Timer는 백그라운드스레드에서 동작하지만 특정시간에 호출되는 코드는 메인스레드에서 동작하도록 했다.</li><li>채널 구독을 한 후 해제를 적절히 하지 않으면 메모리누수가 발생할 수 있어서 채널의 구독시점과 구독해제시점을 명확하게 지정하여 처리했다.</li></ol><h3>⚙️ Tuist</h3><hr><p>Tuist는 프로젝트 구조에 대한 복잡성을 제거하여 Xcode프로젝트를 쉽게 처리할 수 있도록 하는 것을 목표로 하는 도구입니다.</p><p>iOS 개발자가 소수인 경우나, Objective-C라이브러리 중 SPM을 지원하지도 않는 라이브러리가 있는 경우 등인 경우 gitattribute기능을 활용하여 Xcode프로젝트파일 충돌에 대한 대응을 진행할 수 있다.</p><p>하지만 버전이 발전함에 따라 Tuist에서도 Objective-C SPM을 지원하지 않는 라이브러리에 대한 대응하는 방법들이 존재해서 검토를 해보았다.</p><p>지난 주는 기존의 토이프로젝트를 Tuist로 변경하는 작업을 진행해보았다. 3버전과 4버전의 코드와 tuist 명령어가 매우 달라서 처음 버전 설정을 명확히 지정해야겠다.</p><h3>🧹 Clean Architecture</h3><hr><p>토이프로젝트에서 아키텍처패턴을 적용하기 위해서 Clean Architecture에 대한 내용을 공부했다.</p><p>Clean Code 문서를 먼저 읽어보고 iOS에서 Clean Architecture를 적용한 프로젝트를 분석했다.</p><p>Clean Architecture는 역할에 따라 레이어를 분리하고 각 레이어는 종속성패턴을 지켜 영향도를 제거하도록 해주는 아키텍처패턴이다.</p><p>여러 장점들에 대해서 생각해보았고 <a href="https://sookim-1.tistory.com/entry/Clean-Architecture-for-iOS">티스토리블로그에 관련 글</a>을 작성했다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>그동안 작성한 이력서를 검토해보았는데, 내가 작업한 내용을 더 가독성이 좋도록 보정했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/015-20240513</guid><title>번호 : 015, 작성일자: 2024-05-13</title><description>Appstore Connect 알림 이슈 수정, Tuist 맛보기, Fastlane에서 Preview에러, UITabBarController의 ToolTip처리</description><link>https://sookim-1.github.io/posts/015-20240513</link><pubDate>Mon, 13 May 2024 16:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 015, 작성일자: 2024-05-13</h1><h2>2024.05.08 ~ 2024.05.12</h2><h3>🚨 AppstoreConnect 알림</h3><hr><p>갑자기 AppStoreConnect Push로 <code>[앱버전]버전의  진행 상태가 ‘잘못된 바이너리’로 변경되었습니다.</code> 가 전달되었다.</p><p>해당 에러가 발생하면 AppStoreConnect의 메일로 어떤 이유로 발생했는지 메일로 전달되므로 해당 메일 내용을 참고하면 된다.</p><p>메일을 확인해보니 <code>ITMS-90013: Corrupt Image File - The image file 'AppIcon60x60@2x.png' appears to be corrupt.</code> 에러 메시지가 표시되었다. 앱아이콘의 파일이 오류가 되었다는 데 변경한 적이 없어서 찾아보니 애플측의 임시발생한 오류여서 시간이 지나서 자연스럽게 해결되었다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>탭바위에 고정으로 표시되는 툴팁을 구현하기 위해서는 UITabBarController의 메인view에 레이아웃을 잡아주면 탭이 이동하여도 고정으로 표시된다.</li><li>Fastlane을 사용할 때 iterm2를 Rosetta로 실행시키면 <code>#Preview</code> 매크로가 에러가 발생한다.</li><li>Tuist 맛보기를 진행했다. mise툴을 이용하여 버전을 관리하고 기본프로젝트 생성과 3버전과 4버전 공개프로젝트를 클론하여 빌드해보는 작업을 진행했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/014-20240508</guid><title>번호 : 014, 작성일자: 2024-05-08</title><description>사이드프로젝트 1차 완료, Sentry Environment 분리</description><link>https://sookim-1.github.io/posts/014-20240508</link><pubDate>Wed, 8 May 2024 14:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 014, 작성일자: 2024-05-08</h1><h2>2024.05.02 ~ 2024.05.07</h2><h3>🚨 사이드프로젝트 (덕후감)</h3><hr><p>사이드프로젝트의 이름은 덕후감인데 애니메이션을 검색하여 현재 몇화까지 보았는지 저장하는 서비스 - <a href="https://github.com/sookim-1/Geek_Report">Geek_Report</a></p><p>지난 주는 해당 사이드프로젝트의 전체적인 기능을 구현을 완료했다.</p><p><strong>애니메이션별 상세화면</strong></p><ul><li>프롬프트에 원하는 디자인을 입력하면 생성되는 툴인 UIZard를 활용하여 디자인을 참고했고, Strechable Header를 이용하여 구현했다.</li><li>에피소드를 선택하는 방법은 제한된 목록에서 선택하도록 UIPickerView로 기능을 구현했다.</li></ul><p><strong>검색화면</strong></p><ul><li>UISearchController를 이용하여 검색이 될 때 API를 호출하도록 이용했다.</li><li>기존의 홈화면 디자인을 UICompositionalLayout 구성을 사용했기 때문에 동일하게 검색목록 디자인도 UICompositionalLayout을 사용하여 구현했다.</li></ul><p><strong>나의 목록화면</strong></p><ul><li>데이터를 저장하고 불러와서 표시하는 방법으로 CoreData를 활용했다. CoreData를 사용한 이유는 추후에 계정서비스를 도입하면 FirebaseStore를 사용할 예정도 있지만, 계정서비스 도입전에는 Relam, CoreData, SwiftData가 후보였다. 비교하면 Relam은 라이브러리이고 저번 사이드프로젝트에 사용해봤기 때문에 나머지 후보 중 SwiftData는 CoreData의 보완된 부분이 많아서 차이점을 비교하기 위해 CoreData를 먼저 사용했다.</li><li>해당 화면 디자인도 동일하게 UICompositionalLayout을 사용하여 구현했다.</li></ul><p>이제 부터는 에러처리 및 아키텍처패턴에 대한 부분을 리팩토링해나가야겠다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li><a href="https://docs.sentry.io/platforms/apple/guides/ios/configuration/environments/">Sentry environment</a>을 설정하여 빌드옵션에 따라 설정할 수 있다. 기본 값은 production이고 빌드옵션에 따라 Debug모드는 debug, Release모드는 release로 설정하여 분기처리 할 수 있다.</li><li>SkeletonView라이브러리를 사이드프로젝트에 추가하려고 했는데 DiffableDataSource와 사용해본적이 없어서 검토해보았는데 적용이 되지 않아서 더 공부해봐야겠다.</li><li>새로 알게된 tree패키지가 있었는데 디렉토리구조를 tree구조로 표시해준다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/013-20240502</guid><title>번호 : 013, 작성일자: 2024-05-02</title><description>AI 툴 탐색, ATT 프레임워크, DateFormatter 리팩토링, Carousel 배너 구현, UISheetPresentationController, GPG 인증 변경사항, App Groups를 이용한 데이터공유, rbenv를 활용한 ruby 설정</description><link>https://sookim-1.github.io/posts/013-20240502</link><pubDate>Thu, 2 May 2024 13:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 013, 작성일자: 2024-05-02</h1><h2>2024.04.22 ~ 2024.05.01</h2><h3>🤖 AI</h3><hr><p>우연히 AI 툴중에서 그림판에 그림그리듯이 그림을 그리면 HTML, CSS, JS의 코드를 작성해주는 툴을 보고 더 AI툴들을 공부해야겠다고 생각하고 찾아보았다.</p><ul><li><a href="https://uizard.io/">UIZard</a> : 프롬프트에 원하는 디자인을 입력하면 디자인을 AI가 작성해주는 툴이다. 400개 뷰 컴포넌트 이하에서는 무료여서 확인해보았는데 사이드프로젝트를 할 때 도움이 많이 될 것 같다.</li><li><a href="https://www.builder.io/">Builder.io</a> : Figma의 플러그인으로 통합하여 Figma의 디자인을 원하는 프로그래밍언어로 작성해준다.</li><li><a href="https://openai.com/index/introducing-gpts">GPTs</a> : 챗GPT의 신규기능인데 해당 목적에 맞게 GPT를 커스텀하여 사용할 수 있다. GPTs Builder를 통해 여러 사람이 만든 챗봇을 사용할 수 있다. GPT의 유료버전에서만 사용가능하다.</li><li>데빈 : 세계 최초의 AI 소프트웨어 엔지니어, 프롬프트를 입력하면 직접 에러수정을 하면서 코딩을 해주는 프로그램</li></ul><h3>🚨 ATT(AppTrackingTransparency) - 앱 추적 권한</h3><hr><p>Reject 사유는 "AppTrackingTransparency프레임워크를 사용하는 경우 앱 추적 권한 요청팝업을 표시하지 않는다"였다.</p><p>ATT는 iOS 14.5부터 발표되었는데 사용자의 IDFA(광고주 식별자)에 액세스하고 사용자/기기를 트래킹하도록 도와주는 프레임워크인데 동작하기 위해서는 사용자의 앱추적권한을 동의를 받아야 한다.</p><p>그래서 권한요청팝업이 발생하지 않은 이유에 대해서 추론해보았다.</p><ol><li>아이폰 설정 → 개인정보 보호 및 보안 → 추적 → 앱이 추적을 요청하도록 허용 옵션 활성여부를 확인(옵션이 비활성되어있으면 팝업이 발생하지 않는다.)</li><li>iOS17에서 발생한 이슈로 추적권한을 요청하는 메서드인 completion메서드에서 이슈<ul><li>ATTrackingManager객체의 <code>open class func requestTrackingAuthorization(completionHandler completion: @escaping (ATTrackingManager.AuthorizationStatus) -&gt; Void)</code> 의 메서드에서 이슈가 발생해서 <code>open class func requestTrackingAuthorization() async -&gt; ATTrackingManager.AuthorizationStatus</code> 로 변경</li></ul></li></ol><ol start="3"><li>권한요청팝업이 연속적으로 발생한 경우 무시될 수 있는 이슈<ul><li>앱이 모두 로드가 되기 전에 팝업이 발생하면 안되므로 applicationDidBecomeActive에서 권한 요청(애플에서 권장하는 방법)</li><li>Delay를 주어 팝업처리</li></ul></li></ol><p>해당 이유들을 참고하여 수정해서 앱 심사는 통과되었다.</p><h3>📆 DateFormatter</h3><hr><p>우연히 DateFormatter인스턴스를 초기화하는데 비용이 많이 든다는 글을 보았다.</p><p>측정한 글을 보았는데 DateFormatter인스턴스 자체의 생성시간은 짧지만 생성을 하면서 계산하는 작업이 함께될 때 시간이 기하급수적으로 늘어났다.</p><p>그래서 Date를 다루던 코드들을 전역으로 DateFormatter인스턴스를 생성한 후에 처리하도록 변경하면 비용을 줄일 수 있다.</p><p><a href="https://sarunw.com/posts/how-expensive-is-dateformatter/">DateFormatter 분석</a> 해당 블로그글을 참고하였다.</p><h3>🌈 Carousel Page Scale Banner</h3><hr><p>사이드프로젝트의 배너를 Carousel 형식으로 만들고 Page를 표시한 후 아이템이 이동할 때 마다 가운데 Scale이 강조되도록 하는 화면을 만들기로 했다.</p><p><a href="https://github.com/tarikbozyak/AdvancedCompositionalLayout">AdvancedCompositionalLayout</a>의 저장소를 참고했는데 추후 참고하기 좋은 프로젝트여서 나의 코드스타일로 변경하는 작업을 진행했다.</p><p>Combine을 RxSwift로 변경하고, UI구성은 SnapKit, Then라이브러리를 사용했다.</p><ul><li>Carousel 형식은 CompositionalLayout으로 Section을 구성한 후 orthogonalScrollingBehavior를 groupPagingCentered로 설정했다.</li><li>Page 표시는 visibleItemsInvalidationHandler에서 round(offset.x / self.view.bounds.width)로 해당 page번호를 구했다.</li><li>Scale 애니메이션처리는 visibleItemsInvalidationHandler에서 가운데 아이템과 아닌 아이템들의 scale을 CGAffineTransform(scaleX: scale, y: scale) 메서드로 변경했다.</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>BottomSheet를 구현할 때 iOS15이상 부터는 UISheetPresentationController를 지원해서 편리하게 사용할 수 있다.</li><li>App Groups를 이용하면 다른 앱들간의 데이터를 공유할 수 있다.</li><li>GPG키 오류가 발생하여 보았는데 새로운 버전부터 GPG키에 대한 비밀번호를 따로 입력하도록 되었다.</li><li>rbenv란 ruby버전을 여러개를 선택하여 사용할 수 있도록 하는 패키지다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/012-20240422</guid><title>번호 : 012, 작성일자: 2024-04-22</title><description>Modern CollectionView, 티스토리 스킨변경, 티스토리 기능추가, 깃허브 저장소 정리</description><link>https://sookim-1.github.io/posts/012-20240422</link><pubDate>Mon, 22 Apr 2024 17:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 012, 작성일자: 2024-04-22</h1><h2>2024.04.15 ~ 2024.04.21</h2><h3>📱 Modern CollectionView</h3><hr><p>반복적인 데이터를 표시할 때 UICollectionView을 활용하면 편리한 데 iOS14이상에서 새로운 API들이 여러가지가 추가되어서 전부 정리하고 사용해보았다.</p><ul><li>UICollectionViewDiffableDataSource</li><li>UICollectionViewCompositionalLayout</li><li>UICollectionView.CellRegistration</li><li>UIContentConfiguration</li></ul><p>위의 목록처럼 여러가지가 추가되어서 iOS14미만에서 사용했던 방식을 코드로 작성한 후 하나의 API들을 적용시켜가면서 차이점을 분석했다.</p><p>해당 관련 글은 <a href="https://sookim-1.tistory.com/entry/iOS-iOS-14이상에서-UICollectionView-사용하기">iOS 14이상에서 UICollectionView 사용하기</a>에 작성했다.</p><h3>👨🏻‍💻 원격저장소 및 블로그 정리</h3><hr><p>깃허브프로필페이지가 아직도 iOS 공부 중이라고 작성되어 있어 갱신을 해줄 필요성을 느꼈다.</p><p>따라서 깃허브프로필저장소를 제거한 후 내가 자주 확인하거나 표시하고 싶은 저장소와 gist를 pin설정을 하였다.</p><p>티스토리에서 글을 작성하였는데 목차가 옆에 플로팅형태로 표시되면 좋을 것 같아서 확인해보았는데 티스토리에는 여러가지 스킨이 제공되어서 스킨자체에서 여러가지 기능을 제공하는 스킨도 있고, 내가 원하는 기능을 직접 html편집기능을 통해 추가할 수도 있었다.</p><p>따라서 스킨들을 탐방하면서 검색해보았는데 아직은 기본스킨에 목차기능만 추가하는 것이 가장 마음에 들었다.</p><p>구글서치콘솔과 네이버웹마스터도구에도 한번 더 색인을 요청하였다.</p><ul><li><a href="https://github.com/sookim-1">깃허브</a></li><li><a href="https://sookim-1.tistory.com/">티스토리</a></li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>자주 사용하는 코드를 작성하는 경우, Xcode Snippet기능을 활용할 수 있는데 다른 컴퓨터에서도 사용하기 위해 gist에 <a href="https://gist.github.com/sookim-1/04552ce57b1e154a165121c5f064637f">나만의 Snippet</a>을 작성했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/011-20240415</guid><title>번호 : 011, 작성일자: 2024-04-15</title><description>Bottom Sheet 구현, 네이버지도 커스텀마커 적용, UIStackView 사용시 주의사항, Kingfisher Xcode15에서 사용시 주의사항</description><link>https://sookim-1.github.io/posts/011-20240415</link><pubDate>Mon, 15 Apr 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 011, 작성일자: 2024-04-15</h1><h2>2024.04.08 ~ 2024.04.14</h2><h3>📱 Bottom Sheet</h3><hr><p>앱의 어느위치에서든 아래에서 올라오는 스타일을 BottomSheet라고 정의한다.</p><p>BottomSheet는 스크롤에 따라서 화면을 변경할 수 있다.</p><blockquote><p>이번에 구현해보았던 BottomSheet의 조건</p></blockquote><ol><li>스크롤을 위로 특정 높이만큼 되었다면 최대 높이로 화면을 표시</li><li>스크롤을 기본 높이 정도 아래로 내린 경우 기본 높이로 화면을 표시</li><li>스크롤을 최소높이 아래로 내린 경우 화면을 사라지게 하도록 표시</li></ol><p>구현방법은 superview에 UIPanGestureRecognizer를 추가하고 이벤트로 전달받은 UIPanGestureRecognizer의 state를 통해 종료된 경우와 변경 중인 경우를 전달받는다.</p><p>그리고 해당시점에 UIPanGestureRecognizer의 view의 좌표를 전달받아서 처음 설정했던 높이들과 비교하여 BottomSheet의 높이를 변경했다.</p><h3>🗺️ 네이버지도 커스텀마커</h3><hr><p>네이버지도 SDK를 사용 중인 경우 사용자에게 좌표에 대한 정보를 표시하기 위해 마커를 사용할 경우가 있다. 네이버지도에서 마커를 표시하기 위해서는 NMFOverlayImage를 전달해야 하는데 해당 객체를 생성하기 위해서는 UIImage나 에셋의 이미지명을 제공하여 생성할 수 있다.</p><p>하지만, 이미지와 텍스트가 합쳐진 마커를 표시하기 위해서는 커스텀뷰(UIView)를 생성한 후 UIImage로 변경하여 커스텀마커를 표시할 수 있다.</p><p>텍스트가 유동적으로 변경해야하는 조건이 있어서 intrinsicContentSize로 텍스트의 크기를 가져온 후 프레임을 재조정 한 후 layoutIfNeeded 메서드로 업데이트해서 해결할 수 있다.</p><p><a href="https://velog.io/@will_d/iOS-Naver-Map-CustomMarker">iOS Naver Map CustomMarker</a> 해당 블로그를 참고했는데 도움이 많이 되었다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>UIStackView를 생성한 후 SubView들을 추가할 때 실수로 <code>addArrangedSubview</code> 가 아니라 <code>addSubview</code> 로 추가하는지 주의해서 사용해야겠다.</li><li>Xcode 15이상에서 Kingfisher의 <code>ImageResource</code> 타입을 사용한다면 Xcode15에서 새로 추가된 <code>ImageResource</code> 타입과 이름이 동일하여 충돌이 발생한다. 따라서 타입별칭을 이용하여 사용해야한다.<ul></ul></li></ol><pre><code class="language-swift">    typealias KFImageResource = Kingfisher.ImageResource
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/010-20240408</guid><title>번호 : 010, 작성일자: 2024-04-08</title><description>UITabBar 여러가지 활용방법, FireStore와 FirebaseAuth를 활용한 MVVM-Chat 구현, 애니메이션 목록 API Postman 정리, 네이버지도 카메라 Delegate 이슈</description><link>https://sookim-1.github.io/posts/010-20240408</link><pubDate>Mon, 8 Apr 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 010, 작성일자: 2024-04-08</h1><h2>2024.04.01 ~ 2024.04.07</h2><h3>📱 UITabBar, UITabBarController</h3><hr><p>사이드프로젝트를 시작하면서 UITabBar를 활용하여 홈화면을 구성할 예정이여서 여러가지에 대해서 알아보았다.</p><p>1️⃣번째로는 UITabBar를 숨김처리하는 방법은 여러가지인데 한 곳에서 처리하도록 하는 방법을 사용해보았다.</p><p>기존에 숨김처리를 하기 위해서 숨김처리할 화면의 viewWillAppear가 호출될 때 tabbar.isHidden을 하거나 tabbar.frame을 조정하거나, push가 될때 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621863-hidesbottombarwhenpushed"><strong>hidesBottomBarWhenPushed</strong></a>프로퍼티를 활용했는데 매번 새로운화면이 추가될 때 확인을 해야하거나 헷갈릴 수 있기 때문에 한 곳에서 처리를 하도록 하면 관리와 협업을 하는 경우 헷갈리지 않을 수 있고 장점이 많은 것 같다.</p><p>2️⃣번째로는 TabBar의 Item을 선택한 경우 화면이 전환 될 때 애니메이션등을 처리해보았다. 기본적으로 애니메이션 스타일에 대해서는 각각 다를 수 있지만, 처리하는 부분은 모두 비슷한 것 같다. UITabBarControllerDelegate의 메서드인 <a href="https://developer.apple.com/documentation/uikit/uitabbarcontrollerdelegate/1621167-tabbarcontroller"><strong>tabBarController(_:animationControllerForTransitionFrom:to:)</strong></a>에서 UIViewControllerAnimatedTransitioning프로토콜을 채택하는 애니메이터객체를 반환하면 적용이 된다.</p><p>Slide형식과 확대,축소되는 형식 2가지 스타일을 적용해보고 비교해보았다.</p><p>3️⃣번째로는 CustomTabBar로 변경하였다. 기본 TabBar를 변경하는 경우 애니메이션 처리 부분, frame 조정등 제한이 있기 때문에 UIStackView를 활용하여 기본 TabBar를 대체하여 사용했다. 각각의 TabItem은 UIView로 적용했기 때문에 RxGesture를 도입하여 tap이벤트를 적용해보았다.</p><h3>💬 Firebase<em>Learn</em>Project 채팅기능 구현</h3><hr><p>FirebaseAuth와 FireStore를 사용하여 채팅을 구현해보았다. 해당 프로젝트는 여러명이 같은 채팅방도 이용할 수 있는 상황을 고려했다. <a href="https://github.com/sookim-1/Firebase_Learn_Project"><strong>Firebase<em>Learn</em>Project</strong></a>의 프로젝트에서 구현해보았다.</p><p>FireStore DB구조는 FirebaseAuth를 활용하여 각 사용자별 Uid로 구분하고 채팅방을 매칭시키는 구조다.</p><p>채팅관련 코드들은 MVVM구조다.</p><p>FireStore 마지막 채팅내역이 아닌 경우까지 첫 화면은 로딩을 표시하는 방법을 해결하지 못했다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>사이드프로젝트를 위해 애니메이션 목록 관련 API를 찾아보았는데 MyAnimeList API가 유명했고 해당 API를 Copy한 Jikan API가 있었는데 개발하는 시점에 Jikan을 사용하고 완료되면 MyAnimeList로 변경하는 방법을 고려해봐야겠다. 2가지 비교를 위해 Postman에 각 WorkSpace를 생성하여 정리했다.</li><li>네이버지도 iOS SDK를 사용하면 처음 화면에서 NaverMapView가 로드될때 NMFMapViewCameraDelegate 메서드가 호출된다. 첫 로드시 호출을 방지하고 싶은 경우 RxGesture를 활용하여 view가 gesture를 받기 전까지 NMFMapViewCameraDelegate의 메서드 이벤트를 모두 skip한 후 gesture를 받은 후부터 처리하도록 할 수 있다.</li><li>티스토리에 <a href="https://sookim-1.tistory.com/3"><strong>Xcode Preview관련 글</strong></a>을 작성했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/009-20240401</guid><title>번호 : 009, 작성일자: 2024-04-01</title><description>Notification Service Extension, App Switcher상태일 때 앱 화면 변경, VerticalCardSwiper 라이브러리, Notion 정리, Preview 기능 활용, systemLayoutSizeFitting메서드</description><link>https://sookim-1.github.io/posts/009-20240401</link><pubDate>Mon, 1 Apr 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 009, 작성일자: 2024-04-01</h1><h2>2024.03.25 ~ 2024.03.31</h2><h3>📱 Xcode Preview 기능</h3><hr><p>Xcode에서 Preview기능을 활용하면 실제 기기 및 시뮬레이터를 사용하지 않고 최신 상태의 뷰 콘텐츠를 표시할 수 있어서 코드로 화면개발을 할 때 편리하다.</p><p>하지만, 실제 프로젝트에서 여러개의 라이브러리를 추가하고 빌드시간이 오래걸리는 프로젝트인 경우 오히려 실제기기를 빌드하는 게 더 빠른 경우도 있었기 때문에 해당 기능은 주로 빌드시간이 짧은 프로젝트의 경우 편리하다고 생각했다.</p><p>해당 기능은 주로 SwiftUI에서 자주 사용하고 UIKit에서 사용하는 방법이 존재하지만, 프로토콜을 채택해서 구현해서 추가해야되기 때문에 새로운 프로젝트를 생성할 때마다 코드를 추가해야하는 번거로움이 있었다.</p><p>iOS17이상부터 Swift Macro기능을 활용해서 굉장히 간단하게 UIKit에서도 사용할 수 있어서 <a href="https://sookim-1.tistory.com/3">블로그</a>에 정리를 해보았다.</p><h3>😅 systemLayoutSizeFitting</h3><hr><p>UITableView의 Footer가 status별로 변경되는 경우 Footer의 높이를 유동적으로 변경해야 한다. 따라서 <a href="https://developer.apple.com/documentation/uikit/uiview/1622623-systemlayoutsizefitting">systemLayoutSizeFitting(_:withHorizontalFittingPriority:verticalFittingPriority:)</a>를 사용하여 최적크기를 반환하는 메서드를 사용하여 높이를 구하였는데 컨텐츠영역이 짤리는 이슈가 발생했다.</p><p>이유는 targetSize만 지정된 경우에도 최적크기를 구할 수는 있지만, 좀 더 targetSize에 정확한 크기를 얻기 위해 수직제약조건의 파라미터의 값을 설정함으로써 정확한 크기를 반환했다.</p><h3>🔔 Notification Sevice Extension</h3><hr><p>기본적으로 iOS에서는 Remote Notification을 표시하기 위해서는 APNs를 거쳐서 Push를 전달받을 수 있다.</p><p>따라서 APNs에 전송할 때 payload에 필요한 설정 및 정보들을 전달하게 된다.</p><p>알림 종류별로 그룹화하고 새 알림이 온다면 이전 알림들을 제거하는 기능을 구현해보고 싶어서 Extension을 활용하면 적용할 수 있는지 확인해보았지만, 서버에서 데이터를 전달할 때 payload설정을 통해서만 가능한 작업이였다.</p><p>해당 내용을 알게되면서 <a href="https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension">Service Extension</a>으로 활용할 수 있는 작업에 대해서 알아보았다.</p><ul><li>원격알림의 내용을 수정할 수 있는 경우<ul><li>암호화된 형식으로 전송된 데이터의 암호를 해독합니다.</li><li>크기가 최대 페이로드 크기를 초과하는 이미지 또는 기타 미디어 첨부 파일을 다운로드합니다.</li><li>사용자 기기의 데이터를 통합하여 알림의 내용을 업데이트합니다.</li></ul></li></ul><p>요약하자면 alert에 전달된 내용을 변경하는 기능을 담당한다. (텍스트 변경 및 이미지 추가)</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>블로그에 올리는 글을 제외한 모든 글들을 개인 Notion에 정리 중인데 Notion계정이 학생인증으로 인해 네이버이메일로 되어있어서 이제 더 이상 사용할 이유가 없어져서 지메일로 옮기기 위해 모든 페이지를 옮기는 작업을 진행했다. 또한, 페이지들을 관리하기 편하기위해 Notion의 데이터베이스기능을 활용하여 나만의 템플릿을 지정하여 정리하였다.</li><li>현대카드 iOS앱을 보았는데 카드형식으로 넘기는 UI가 있어서 구현하는 방법을 살펴보았다. 관련된 라이브러리 중 <a href="https://github.com/JoniVR/VerticalCardSwiper">VerticalCardSwiper</a>라는 라이브러리가 있었다. 해당 라이브러리의 코드를 보고 어떻게 구현했는지 살펴보았다.</li><li>금융 및 카드앱에서 백그라운드로 가는 경우 앱의 화면이 가려지는 경우가 있어서 어떻게 구현했는 지 보았는데 App Switcher 상태라고 하는 상태가 있어서 아이폰에서 앱을 들어올린 경우에 대해서 정의한 상태였다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/008-20240325</guid><title>번호 : 008, 작성일자: 2024-03-25</title><description>HTML 텍스트 처리, Atributika 라이브러리, App Hangs, NSTimer 비동기 작업 처리, Xcode Discard 복구</description><link>https://sookim-1.github.io/posts/008-20240325</link><pubDate>Mon, 25 Mar 2024 16:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 008, 작성일자: 2024-03-25</h1><h2>2024.03.18 ~ 2024.03.24</h2><h3>📱 HTML 텍스트 표시하기 (+ Atributika 라이브러리)</h3><hr><p>모바일앱은 배포를 하게되면 수정사항이 필요한 경우 심사요청을 한 후 심사가 완료되어야 배포를 진행할 수 있다. 그런데 자주 변경되어야 하는 텍스트로 인해 여러번 배포하는 일을 피하기 위해서 서버에서 해당 텍스트를 내려줄 수 있다.</p><p>그런데, 서버에서 내려주는 텍스트의 스타일도 포함시키고 싶은 경우 HTML텍스트를 이용하면 편리하게 사용가능하다.</p><p>간단한 구현방식은 HTML텍스트를 data로 변환 후 디코딩하여 NSAttributedString형식으로 반환해주면 UILabel 또는 UITextView에 표시할 수 있다.</p><p>하지만 순서없는 목록을 표시하기 위해 <code>&lt;ul&gt;</code> , <code>&lt;li&gt;</code> 태그를 사용하는 경우 <code>&lt;br&gt;</code> 태그가 있는 줄에 bullet point가 생성되는 이슈가 있다. 기본적으로 apple에서 어떤식으로 디코딩하는지에 대한 원리를 제공하지 않기 때문에 차선책으로 Atributika라는 라이브러리를 도입하여 해결할 수 있다. Atributika를 사용하여 <code>&lt;li&gt;</code> 태그를 bullet point문자로 변환한 후 스타일을 적용하도록 하면 bullet point가 원하는 대로 생성된다.</p><p>Atributika라이브러리에 대한 글이 많지 않아 티스토리블로그에 글을 작성하여 올렸다.</p><ul><li><a href="https://sookim-1.tistory.com/2">Atributika라이브러리 (HTML to NSAttributedString)</a></li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>Sentry에서 AppHanging이라는 이슈는 WatchDog 스레드에 sentry에서 제공하는 AppHangTracker를 시작하여 주기적으로 메인스레드가 제한시간내에 작업항목을 실행하는지 확인한 후 2초이상 응답하지 않으면 AppHanging 이벤트가 생성된다고 한다. Sentry 문서에서도 예외상황이 여러 가지 있다고한다. 해당 옵션은 비활성화가 가능하다.<ul><li><a href="https://developer.apple.com/documentation/xcode/understanding-hangs-in-your-app">Apple - <strong>Understanding hangs in your app</strong></a></li><li><a href="https://docs.sentry.io/platforms/apple/configuration/app-hangs/">Sentry - App Hangs</a></li></ul></li></ol><ol start="2"><li>Xcode에서 변경 작업사항들을 Discard 했을 때, 복구하고 싶다면 Mac의 TextEdit(텍스트편집기)를 이용하여 복구할 수 있는 방법을 찾았다.<ul></ul></li></ol><ol start="3"><li>NSTimer에서 동작한 작업이 비동기 작업인 경우 NSTimer를 종료시켜도 비동기 작업은 별개로 진행되기 때문에 비동기 작업이 완료되었을 때 NSTimer가 nil인 경우 처리를 하지 않도록 하는 방법을 찾았다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/007-20240318</guid><title>번호 : 007, 작성일자: 2024-03-18</title><description>CollectionView Compositional Layout 관련 이슈, UI 관련 이슈, Bitbucket STALE 태그</description><link>https://sookim-1.github.io/posts/007-20240318</link><pubDate>Mon, 18 Mar 2024 17:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 007, 작성일자: 2024-03-18</h1><h2>2024.03.11 ~ 2024.03.17</h2><h3>📱 CollectionView Compositional Layout</h3><hr><p>Compositional Layout을 사용했을 때 생기는 상황 1. 셀 터치 - 셀이 터치되었을 때 UI를 변경하기 위해서 <code>isSelected</code>를 상속받아 값이 변경될 때 UI를 변경한다면 세밀한 커스텀동작을 구현할 수 없어서 <code>cellForRowAt</code>메서드에서 조건문 또는 플래그를 이용해서 선택된 셀과 선택되지 않은 셀들의 UI를 설정하는 방법을 고려할 수 있다. 2. 셀 Highlight - 셀이 터치되었을 때 Highlight처리가 되지 않아야 하는 경우가 있다. UITableViewCell에는 <code>selectionStyle</code> 을 none으로 설정할 수 있지만 UICollectionViewCell은 지원하지 않았다. 그래서, <code>shouldHighlightItemAt</code>메서드에서 해당 셀만 Highlight되지 않도록 수정했다. 해당 메서드에서 <code>return false</code>를 하면 셀이 터치가 안되는 이슈가 있다. 다른 방법을 고려해야 겠다. 3. 섹션 헤더 및 풋터 숨김처리 및 섹션 높이 관련 수정들 - 예를 들어, 셀이 터치되었을 때 섹션의 헤더 및 풋터 높이를 수정하거나 숨김처리를 하고 싶은 경우 collectionView를 reload하게되면 collectionViewLayout을 재설정하게 되는데 섹션 풋터를 숨기고싶다면 <code>section.boundarySupplementaryItems</code> 에 섹션헤더만 주입하거나 섹션 풋터 높이를 변경하고 싶다면 footer의 height를 변경하면 된다. → <strong>즉, reload를 하는 경우 레이아웃을 재설정해주면 된다.</strong> 4. 태그목록 UI를 구현하는 경우 레이블 텍스트 짤림 이슈 - 태그목록 UI를 Compositional Layout을 사용하여 구현하는 경우 reload를 하게 되면 셀의 너비를 estimated로 너비를 계산하기 때문에 레이블의 텍스트가 짤리는 이슈가 발생했다. 해당 이슈를 해결하기 위해 임의의 텍스트를 prepareForReuse에도 추가하거나 레이아웃을 재설정시도등을 하였지만, 해결되지 않았다. 그래서 estimated의 계산방식을 찾아보려고 했지만 애플에서 정확히 어떤식으로 너비를 계산하는지 알려주지 않고 있는 것 같다. 추후 정확한 이슈 원인에 대해서 자세히 찾아봐야겠다.</p><h3>🚀 UI 관련 이슈</h3><hr><ul><li>SnapKit을 사용할 때 safeArea기준으로 constraints를 작성하면 updateConstraints를 사용할 수 없다.</li><li>테이블뷰 섹션 풋터를 <code>systemLayoutSizeFitting</code> 을 사용하여 Height를 계산한 후 섹션 풋터 내부의 stackview를 superview의 bottom에 맞추면 stackview가 짤리는 이슈가 발생한다.<ul><li>테이블뷰 섹션 풋터 높이를 계산하는 <code>systemLayoutSizeFitting</code> 원리를 추후 자세히 찾아봐야겠다.</li></ul></li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>Bitbucket Pull Request목록에 STALE태그가 표시되었는데 확인해본 결과 PR이 평소보다 오래 열려있거나 최근에 업데이트 되지 않은 경우 표시된다고 한다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/006-20240311</guid><title>번호 : 006, 작성일자: 2024-03-11</title><description>FCM Token 갱신, CollectionView Compositional Layout, FireStore 사용 시 빌드시간 증가 이슈, 깃허브 블로그 마크다운 이모지 배포 이슈</description><link>https://sookim-1.github.io/posts/006-20240311</link><pubDate>Mon, 11 Mar 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 006, 작성일자: 2024-03-11</h1><h2>2024.03.04 ~ 2024.03.10</h2><h3>🔄 FCM Token 갱신</h3><hr><p>Firebase 프로젝트를 Debug, Release 별로 나누어 사용 중인 경우 FCM Token관리가 중요하다. 기기에서 빌드환경이 Debug로 설치된 상태에서 Release로 앱을 다시설치하는 경우 FCM Token이 변경될 수 있다.</p><p>fcmToken의 값이 변경되는 시점은 아래 4가지 경우이다.</p><ul><li>새 기기에서 앱 복원</li><li>사용자가 앱 제거/재설치</li><li>사용자가 앱 데이터 소거</li><li>앱이 인스턴스 ID를 삭제</li></ul><p>FCM을 직접 갱신하기 위해서는 삭제 후 조회를 하면 된다. 아래코드는 FCM 토큰을 직접갱신하는 코드인데, 삭제는 옵셔널이다.</p><pre><code class="language-swift">// FCM 토큰 삭제
Messaging.messaging().deleteToken { error in
    print(error)
}

// FCM 토큰 조회
Messaging.messaging().token { token, error in
  if let error = error {
    print("Error fetching FCM registration token: \(error)")
  } else if let token = token {
    print("FCM registration token: \(token)")
  }
}
</code></pre><h3>📱 CollectionView Compositional Layout</h3><hr><p>반복되는 데이터를 표시하는 경우와 추후 확장성을 위해서는 CollectionView Compositional Layout를 사용할 수 있다. CollectionView Compositional Layout을 사용할 때는 기본적인 UICollectionViewDataSource와 사용할 수 도 있고 UICollectionViewDiffableDataSource와도 사용할 수 있다. UICollectionReusableView를 사용하여 각 섹션별 Header, Footer를 구현하는 경우, viewForSupplementaryElementOfKind 메서드에서 조건문을 조심하지 않으면 재사용되기 때문에 주의해서 사용해야겠다.</p><h3>🚀 FireStore 사용 시 빌드시간 증가 이슈</h3><hr><p>지지난 주 FireStore를 사용하는 프로젝트의 경우 빌드시간이 기하급수적으로 증가한 이유에 대해서 확인해보았는데 일단 FireStore를 사용한다면 빌드시간이 엄청나게 증가한 것은 확인했다. 빌드시간 단축을 위해 찾아본 결과 FireStore는 C++로 구성된 파일이 많은데 Xcode로 빌드하는 경우 컴파일할 때 시간이 증가할 수 있다는 내용을 <a href="https://github.com/invertase/firestore-ios-sdk-frameworks">FireStore iOS SDK 저장소</a>의 ReadMe에서 확인을 했다.</p><ul><li>기존의 pod 설치 명령어는 <code>pod 'FirebaseFirestore', '10.19.0'</code> 이였다.</li><li>변경된 pod 설치 명령어는 <code>pod 'FirebaseFirestore', :git =&gt; '&lt;https://github.com/invertase/firestore-ios-sdk-frameworks.git&gt;', :tag =&gt; '10.19.0'</code> 로 변경했다.</li></ul><p>빌드시간이 FireStore로 변경 전과 유사하게 줄어들었다. 즉, 미리 컴파일된 바이너리파일에서 FireStore를 사용하도록 변경한 것이다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>깃허브 블로그를 Swift언어를 사용한 Publish라이브러리를 사용하여 배포 중인데 마크다운 문법 중 특정 이모지를 사용하면 배포 workflow가 실패하는 부분이 있어서 해당 부분을 수정했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/005-20240304</guid><title>번호 : 005, 작성일자: 2024-03-04</title><description>Custom Push, APNs Payload 형식, 앱스토어 Reject, 빌드 시간 단축, Appstore Connect, Sentry fastlane plugin</description><link>https://sookim-1.github.io/posts/005-20240304</link><pubDate>Mon, 4 Mar 2024 18:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 005, 작성일자: 2024-03-04</h1><h2>2024.02.27 ~ 2024.03.03</h2><h3>🔥 Push 신규 케이스 추가 및 Custom Push</h3><hr><p>iOS에서는 실시간통신을 위하여 Socket을 사용할 수 있다. 하지만 앱이 백그라운드로 이동한 경우 Socket 연결을 해제한다.(socket-io 공식문서) 이런 경우, Push에서 데이터를 추가하여 백그라운드에서 데이터를 전달받을 수 있다.</p><p>안드로이드와 달리 iOS에서는 APNs로 Payload형식을 맞추어 값을 지정하여 Push를 전송해야 APNs에서 기기로 전달을 하는데 형식을 맞추어서 전달해야 한다. AppDelegate에서 Background에서 Push처리와 Foreground에서 Push처리를 각각 상황별로 처리할 수 있다.</p><p>Custom Push를 구현하기 위해서 Push에 Attachment를 이용하여 이미지를 전달받는 방법과 값을 변경하는 방법등 <a href="https://ios-development.tistory.com/1280">김종권iOS블로그 - Push 섹션</a>를 참고하여 테스트를 해보았다. 구현도중 Notification Service Extension을 진행하면서 발생한 이슈가 한가지 있었는데 <strong>Command ValidateEmbeddedBinary failed with a nonzero exit code</strong> 해당 에러는 Notification Service Extension 타겟의 Bundle Version들이 Host 타겟과 다르기 때문에 발생한 이슈여서 버전을 맞춰주면 해결했다.</p><h3>🛫 앱스토어 Reject</h3><hr><p>Reject 사유는 <strong>Guideline 2.1 - Performance - App Completeness</strong> 심사자의 아이패드 에어에서 흰 화면에서 진행이 안되는 이슈였다. fastlane을 이용하여 Testflight배포를 하는데 Archive를 진행하는 도중 일부 오류가 발생한 것 같다. fastlane을 업데이트 한 후 다시 배포를 한 후 심사자와 동일한 환경으로 실행해본 후 확인한 후 해결되었다. 과거에 관련한 이슈가 있었는데 fastlane을 이용해 서로 다른 컴퓨터에서 배포하였을 때 어떤 버전에서는 특정 iOS버전이 빌드가 잘 되었고, 다른 컴퓨터에서 배포한 버전에서는 특정 iOS버전이 충돌이 나는 이슈가 있었다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>FireStore를 CocoaPod으로 설치하면 기하급수적으로 프로젝트 빌드시간이 증가된다.(약 2배) 빌드시간을 계산하기 위해서는 Xcode 빌드시간을 계산하는 옵션을 활성화하고 무거운작업을 할 것 같은 코드블록에 경고표시를 하여 원인을 확인할 수 있다.</li><li>AppStore Connect에서 프로파일, 인증서, 기기등을 정리했다.</li><li>fastlane을 이용하여 sentry를 upload할 때 plugin을 변경하면 소스코드를 더 자세히 표시할 거로 예상했는데 예상과 다르게 동일하여서 더 자세히 알아봐야겠다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/004-20240227</guid><title>번호 : 004, 작성일자: 2024-02-27</title><description>FireStore DB 구조 설계, Sentry 업그레이드, Bitbucket HTTPS 인증, git credential helper</description><link>https://sookim-1.github.io/posts/004-20240227</link><pubDate>Tue, 27 Feb 2024 14:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 004, 작성일자: 2024-02-27</h1><h2>2024.02.19 ~ 2024.02.26</h2><h3>🔥 FireStore DB 구조 설계</h3><hr><p>FireStore를 사용하여 데이터를 저장한다면 FireStore에 어떤식으로 데이터를 저장할지 DB 구조 설계를 해야한다. 확장성을 고려해서 하면 추후 추가되었을 때 저장된 데이터를 전부 변경하지 않아도 된다.<br>설계를 진행할 때는 FireStore문서에 있는 데이터형식등을 참고한다. 신기했던 데이터형식 중 하나는 reference라는 데이터형식이 있었는데 특정 문서를 참고할 수 있는 게 데이터를 변경할 때 편리할 것 같다.</p><h3>🛫 Sentry</h3><hr><p>Sentry를 공식문서를 확인해 봤다.</p><p><a href="https://sentry.io/for/cocoa/">Cocoa Sentry</a> 를 확인해본 결과 iOS말고도 macOS, watchOS, visionOS, tvOS등 모두 지원하고 충돌로그만 보는 것이 아니라 성능확인도 할 수 있고, HTTP status Code별로 표시여부를 설정할 수 있고 앱이 사용자이벤트를 받을 수 있는지 모니터링 하는 애플 자체의 WatchDog 종로여부도 표시할 수 도 있었다. 충돌로그를 확인하고 충돌을 해결하기 위한 목적으로만 사용하려면 다른 옵션들(Http 종료여부, WatchDog 종료여부는 미표시)을 제외하고 충돌시 추가데이터(충돌시 프로젝트의 코드 표시, 스크린샷과 뷰의 계층구조 첨부파일 추가)를 보내도록 하는 것이 좋을 것 같다.</p><h3>🗺️ Bitbucket HTTPS 인증</h3><hr><p>Bitbucket은 HTTPS를 이용하여 비공개저장소에 접근할 때 인증방식을 App Password를 통해 진행한다.</p><p>AppPassword를 발급받을 때는 권한허용범위를 지정한 후 발급받을 수 있어서 해당 범위를 처음부터 설정을 할 때 고려해야 했다. 그래서 Mac Runner에 설정된 AppPassword를 재발급받고 Mac Runner의 AppPassword 설정된부분을 모두 수정하였다.</p><p>git credential-helper를 사용하면 맥북의 키체인을 통하여 저장된 AppPassword를 가져와여 인증을 할 수 있어서 credential-helper도 설정하여서 인증부분관련해서는 작업을 모두 마쳤다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>버튼을 클릭할 때 API호출을 완료후 화면전환 하는 경우 빠르게 중복클릭하면 화면이 여러번 전환되는 경우, 하나의 화면에서 UI Componente들이 변경될 때 매끄럽지 않은 경우등을 수정하면 앱 안정성이 향상된다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/003-20240219</guid><title>번호 : 003, 작성일자: 2024-02-19</title><description>FirebaseRealtimeDatabase와 FireStore 비교, CI/CD + Mac 초기설정, API 호출 Tip, 앱스토어 - 세금 및 계약</description><link>https://sookim-1.github.io/posts/003-20240219</link><pubDate>Mon, 19 Feb 2024 16:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 003, 작성일자: 2024-02-19</h1><h2>2024.02.13 ~ 2024.02.18</h2><h3>🔥 FirebaseRealtimeDatabase vs FireStore</h3><hr><p>Firebase에서 데이터를 저장하는 서비스 중 대표적인 2가지 FirebaseRealtimeDataBase와 FireStore에 대해서 비교해보았다. 간단하게 FirebaseRealtimeDataBase 서비스와 비교하여 속도, 관리, 비용측면등등 대부분 FireStore를 권장한다고 하고 Firebase팀에서도 권장하는 서비스라고 한다. FireStore, FirebaseStoreSwift를 사용하기 위해서는 라이브러리버전을 10버전이상으로 설치해야 한다. CocoaPod을 사용하여 Firebase를 추가할 때는 <a href="https://cocoapods.org/">Cocoa Pod</a> 검색창에서 라이브러리 검색후 <a href="https://github.com/CocoaPods/Specs">CocoaPods Spec</a> 이동하여 dependencies 키값 확인 후 따로 설치하는 것들 제거, 버전별 맞춤처리를 하여 작업을 진행해야 한다. 왜냐하면 Firebase 제품들은 의존성이 복잡하기 때문이다. FireStore는 파일을 들고 있는 폴더가 Collection이라고 생각하고 파일을 Document로 생각하니까 DB구조가 이해하기 쉬웠다.</p><h3>🛫 CI/CD + Mac 초기설정</h3><hr><p>맥북을 초기화해서 homebrew, cocoapod, git-lfs, git, sourcetree, xcode등등 필요한 프로그램들을 모두 설치했다. 빗버킷에서는 비공개저장소에 접근할 때 접근하는 모든 컴퓨터에 SSH Key를 등록하지 않은 경우 SSH방식을 사용하는 것보다 HTTPS방식을 사용하는 것이 간편한다. 앱암호를 발급받고 비공개저장소에 접근할 때 앱암호를 입력해주기만 하면 되기 때문이다.</p><p>Slack Slash 작업도중 빗버킷 파이프라인을 구동하려면 Runner가 상시 켜져있어야 했다. Flask앱을 PythonAnywhere에서 작동을 하고 있기 때문에 빗버킷의 앱암호는 보안이 중요하기 때문에 <a href="https://help.pythonanywhere.com/pages/environment-variables-for-web-apps/">.env사용방법</a>을 확인한 후 적용했다.</p><h3>🗺️ API 호출 Tip</h3><hr><ol><li>동일한 API를 호출할 때 에러메시지 표기를 통일한다.</li><li>API 호출을 줄일 수 있는 경우 최대한 호출을 줄이도록 구현한다. (모바일앱에서는 가장 무거운 작업이 네트워킹이기 때문이다.)</li><li>API 문서는 잘 확인하고 업데이트를 최신화 한다.</li></ol><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>앱내에 인앱결제가 없거나 유료앱이 아니라면 앱스토어 - 세금 및 계약을 변경하지 않아도 된다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/002-20240213</guid><title>번호 : 002, 작성일자: 2024-02-13</title><description>Dart언어 학습, Legacy 코드 영향, Sentry 도입, CI/CD 고도화</description><link>https://sookim-1.github.io/posts/002-20240213</link><pubDate>Tue, 13 Feb 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호 : 002, 작성일자: 2024-02-13</h1><h2>2024.02.05 ~ 2024.02.12</h2><h3>🚴🏻‍♂️ Dart 언어 접근</h3><hr><p>지난 주부터 노마드코더에서 진행하는 Flutter챌린지를 시작했다.</p><p>Flutter는 Dart라는 프로그래밍언어를 사용 중이기 때문에 Dart언어에 대해서 먼저 시작했다.</p><p>Dart언어를 공부하면서 가장 신기했던 점은 컴파일러가 다양하다는 점이였고 대부분의 문법은 최신 프로그래밍언어들과 큰 차이가 없는 것 같았다.</p><p>Dart언어특징, 변수, 자료형, 함수, 클래스에 대해서 이번주 모두 강의가 끝났다.</p><p>강의의 특징은 Dart언어의 모든 부분을 학습하는 것이 아니라 Flutter를 사용하는데 필요한 수준정도로만 진행하는 것 같았다.</p><h3>🚨 Legacy 코드 영향</h3><hr><p>프로젝트에서 프로그래밍언어 또는 라이브러리등이 업데이트가 되었을 때나 새로운 코드를 작성했을 때 영향이 갈 수 있는 기존 코드(Legacy)를 자세히 보는 습관을 가져야겠다.</p><h3>🚀 Sentry</h3><hr><p>모바일앱에서 충돌이 발생했을 때 어떤 이유로 충돌이 발생했는지 알려주는 서비스로 대표적으로 Firebase Crashlytics를 사용한다.</p><p>Firebase Crashlytics는 무료이고 모바일이라는 범주안에서는 괜찮은 선택인 것 같다. 하지만 서버가 충돌했을 때 로그를 기록하기 위해서 Sentry라는 서비스도 좋은 도구라고 한다.</p><p>Sentry를 확인해보고 느낀 점은 조금 더 충돌이유와 충돌시점에 스크린샷, 뷰의 상관관계등 옵션들이 매우 다양했다.</p><h3>🛫 CI/CD</h3><hr><p>Firebase AppDistribution란? 앱파일을 배포한 후 해당 서비스를 이용하여 앱을 다운로드하고 테스트할 수 있는 서비스다. 기존의 Apple에서 사용하는 TestFlight와 유사하지만 안드로이드는 TestFlight를 사용할 수 없지만 AppDistribution은 안드로이드, iOS 모두 사용가능하다.</p><p>iOS에서 사용하기 위해서는 AppTester라는 앱을 다운로드 받아야한다. 하지만 앱을 직접 다운로드할 수는 없고 웹사이트 바로가기형태로 앱을 다운로드 받을 수 있다. iOS에서 사용했을 때 느낀점은 속도는 TestFlight보다 빠른 것 같지만 프로파일설정도 해야하고 기기등록도해야하는 등 처음설정하는 부분이 복잡한 것 같았다. 그래서 안드로이드를 배포할 예정이 없는 프로젝트의 경우는 접근성이 편리한 TestFlight를 자주 사용할 것 같다.</p><p>지지난주에 만든 Slack Slash를 이용하여 배포하는 작업을 조금 변형하여 Jenkins를 이용해서 Bitbucket pipeline을 트리거하려고 Jenkins에 대해서 공부했다. 하지만 Jenkins에서 해당 파이프라인을 실행하기 위해서는 동작하는 머신이 Mac이여야 한다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><ol><li>네이버지도 SDK에서는 카메라영역을 제한하여 지도가 제한한 영역밖으로 이동하지 못하게 하는 기능이 있다.</li><li>FCM토큰을 관리할 때 옛날에는 직접 재발급하는 코드를 제공해왔지만 현재기준으로 공식문서에서는 직접 재발급하는 작업을 권장하지 않는 것 같다.</li><li>프로젝트에서 메모리해제여부는 항상 확인하며 작업을 진행해야 한다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/posts/001-20240205</guid><title>번호: 001, 작성일자: 2024-02-05</title><description>접근권한 관련 Reject 대응, iOS 자동배포 구축, 블로그 생성</description><link>https://sookim-1.github.io/posts/001-20240205</link><pubDate>Mon, 5 Feb 2024 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>번호: 001, 작성일자: 2024-02-05</h1><h2>2024.01.29 ~ 2024.02.04</h2><h3>🫠 접근권한 관련 Reject</h3><hr><p>Reject 사유는 Guideline 5.1.1 - Legal - Privacy - Data Collection and Storage 였는데 상세 사유에는 카메라, 사진 접근권한에 대한 설명이 충분하지 않았다는 것이였다.</p><p>심사에서 접근권한에 대한 설명을 변경한 경우 해당 설명문이 자세하지 않은 경우 받는 Reject사유라고 한다.</p><p>따라서 앱을 첫 설치할 때 접근권한 안내페이지의 문구와 Info.plist 권한 요청문구를 통일시키고 목적에 대해서 자세히 작성하여 통과했다.</p><p>해당 Reject은 목적을 명확히 작성하여 해결할 수 있다. 아래 예시처럼 접근권한을 어디서 사용할지 명확히 안내한다.</p><ul><li>Camera : 프로필 사진촬영에 카메라접근권한이 필요합니다.</li><li>Photo : 프로필 사진 설정을 위해 사진첩접근권한이 필요합니다.</li></ul><h3>🛫 Slack + Flask + Bitbucket Pipeline + Fastlane</h3><hr><p>Slack 명령어를 이용하여 Testflight에 배포하는 방법이 있다고 하여서 적용해보았다.</p><p>기존프로젝트에서 작업을 진행하면 테스트버전이 계속 추가되어 TestFlight에 버전관리가 힘들어 질것 같아서 새로운 프로젝트에서 작업을 진행했다.</p><p>작업은 Slack Slash명령어를 입력하면 Flask앱에서 Bitbucket Pipeline을 trigger한 후, Pipeline에서 Fastlane명령어를 실행하여 TestFlight에 배포되는 작업이였다.</p><p>모두 완료 후 도입하게 된다면 bitbucket Pipeline을 빌드하기 위한 Runner가 self-hosted를 통해 진행해야 하므로 원격호스팅을 도입해야 하는 제약이 있지만 만약 Github Action을 사용하면 해결될 수 도 있을 것 같다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr><p>티스토리 블로그와 Velog, 깃허브 블로그들의 장단점에 대해서 분석해보고 기존의 Velog의 카테고리 관리가 불편하다고 느껴서 개발관련 글은 모두 티스토리블로그로 이전하고 깃허브블로그에서는 회고록을 작성하도록 정했다.</p><p>관련 링크</p><ul><li><a href="https://sookim-1.tistory.com/">sookim's 티스토리 블로그</a></li><li><a href="https://velog.io/@sookim-1/posts">sookim's Velog</a></li><li><a href="https://sookim-1.github.io/">sookim's GithubBlog</a></li></ul><p>지난 주 이슈와 신규작업은 주소 관련된 작업을 진행했다.</p>]]></content:encoded></item></channel></rss>