<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>sookim-1</title><description></description><link>https://sookim-1.github.io</link><atom:link
    href="https://sookim-1.github.io/feed.rss"
    rel="self" type="application/rss+xml"
/><language>en</language><generator>Ignite v0.1.0</generator><image><url>https://sookim-1.github.io/images/favicon.png</url><title>sookim-1</title><link>https://sookim-1.github.io</link><width>32</width><height>32</height></image><item><guid isPermaLink="true">https://sookim-1.github.io/ko/036-20241014</guid><title>번호 : 036, 작성일자: 2024-10-14</title><link>https://sookim-1.github.io/ko/036-20241014</link><description><![CDATA[Swift 6부터 코드를 테스트하기 위해 편리한 Swift Testing 프레임워크가 발표되었습니다.]]></description><pubDate>Mon, 14 Oct 2024 11:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[UnitTest]]></category><category><![CDATA[UITest]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[Concurrency]]></category><content:encoded><![CDATA[<h2>2024.10.07 ~ 2024.10.13</h2><h3>✅ Swift Testing</h3><hr /><p>Swift 6부터 코드를 테스트하기 위해 편리한 Swift Testing 프레임워크가 발표되었습니다.</p><p>사용해보기 위해 기존 XCTest 프레임워크를 사용한 테스트코드를 마이그레이션 해보았습니다.</p><blockquote><p>간단하게 적용한 것들</p></blockquote><ol><li>결과값을 확인하기위한 assertion들의 함수는 모드 #expect 매크로로 통일되어서 더 명확해지고 사용도 간단했습니다.</li><li>네트워킹코드도 async ~ await 문법을 사용하면 기존에 대기시간을 설정하는 코드도 사용할 필요가 없었습니다.</li><li>테스트함수를 작성할 때 @Test만 붙여주면 테스트함수로 인식하고 인자들을 여러개 배열로 넘겨줄 수 있고 그 외 여러가지 옵션도 제공합니다.</li></ol><p>애플에서 🔗 <a href="https://developer.apple.com/documentation/testing/migratingfromxctest">Migrating a test from XCTest</a> 해당 문서를 제공하기도 하고 프로젝트 생성시 UnitTest 프레임워크 기본값이 Swift Testing이므로 해당 프레임워크를 사용하도록 권장하는 것 같다.</p><h3>🌎 async ~ await</h3><hr /><p>Swift에서 5.5부터 지원하는 Swift Concurrency 중 하나인 async ~ await 문법에 대해서 살펴봤다.</p><p>기존에 비동기코드를 작성할 때 completionHandler, DispatchQueue, RxSwift, Combine 등등이 있다. async ~ await은 비동기코드를 동기처럼 작성하도록 도와줍니다.</p><blockquote><p>async & await 사용시 장점</p></blockquote><ol><li>가독성 향상 - 비동기코드를 동기처럼 작성하기 때문에 콜백지옥에서 벗어날 수 있다.</li><li>throw 키워드와 함께 사용하면 에러처리가 편리하다.</li><li>실수 방지 - completionHandler를 사용했을 때 개발자가 실수로 completion을 하지 않는 것을 방지할 수 있다.</li><li>테스트 용이 - 테스트코드를 작성할 때 Swift Testing과 사용하여 편리하게 사용 가능하다.</li></ol><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>Tip 개발서비스 비용에 대해서는 모니터링을 중요시 하자. (미사용 서비스 비용청구 이유, 비용 산정 이유, 히스토리 등등)</li><li>iOS에서 기본 일기앱이 있는데 해당 앱을 공유기능이 없어서 공유가 가능한 앱을 SwiftUI로 구현해봐야겠다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/036-20241014_en</guid><title>Number: 036, Date: 2024-10-14</title><link>https://sookim-1.github.io/en/036-20241014_en</link><description><![CDATA[Starting from Swift 6, a convenient Swift Testing framework has been introduced for testing code.]]></description><pubDate>Mon, 14 Oct 2024 11:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[UnitTest]]></category><category><![CDATA[UITest]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[Concurrency]]></category><content:encoded><![CDATA[<h2>2024.10.07 ~ 2024.10.13</h2><h3>✅ Swift Testing</h3><hr /><p>Starting from Swift 6, a convenient Swift Testing framework has been introduced for testing code.</p><p>To explore its capabilities, I migrated my existing test code, which was written using the XCTest framework, to Swift Testing.</p><blockquote><p>Key features applied:</p></blockquote><ol><li>All assertion functions for checking result values have been unified under the <code>#expect</code> macro, making them clearer and easier to use.</li><li>When using the <code>async</code> and <code>await</code> syntax for networking code, there’s no need for the old wait-time configurations.</li><li>Simply adding <code>@Test</code> to a test function makes it recognizable as a test, and it allows passing multiple arguments as an array, along with various other options.</li></ol><p>Apple also provides the 🔗 <a href="https://developer.apple.com/documentation/testing/migratingfromxctest">Migrating a test from XCTest</a> guide, and since Swift Testing is the default UnitTest framework when creating a new project, it seems recommended to use it.</p><h3>🌎 async ~ await</h3><hr /><p>I reviewed the <code>async</code> and <code>await</code> syntax, one of the Swift Concurrency features introduced in Swift 5.5.</p><p>Traditionally, asynchronous code could be written using completion handlers, <code>DispatchQueue</code>, RxSwift, Combine, etc. The <code>async</code> and <code>await</code> syntax helps write asynchronous code in a synchronous-like manner.</p><blockquote><p>Benefits of using async & await:</p></blockquote><ol><li>Improved readability – Since the asynchronous code is written as if it’s synchronous, it avoids callback hell.</li><li>Easier error handling – When used with the <code>throw</code> keyword, error handling becomes simpler.</li><li>Prevents mistakes – It prevents the common mistake of forgetting to call the completion handler.</li><li>Easier testing – It works seamlessly with Swift Testing, making it easier to write test code.</li></ol><h3>🙋🏻‍♂️ Other Notes</h3><hr /><ol><li>Tip: It’s crucial to monitor the costs of development services (e.g., reasons for being charged for unused services, cost breakdowns, history, etc.).</li><li>I have a basic diary app on iOS, but it doesn’t have a sharing function, so I should try to implement an app that can be shared with SwiftUI.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/035-20241007</guid><title>번호 : 035, 작성일자: 2024-10-07</title><link>https://sookim-1.github.io/ko/035-20241007</link><description><![CDATA[기본적으로 Xcode 16을 사용하기 위해서는 macOS를 Sequoia 15.0으로 업데이트 해야합니다.]]></description><pubDate>Mon, 07 Oct 2024 14:30:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[Tuist]]></category><category><![CDATA[UnitTest]]></category><category><![CDATA[UITest]]></category><category><![CDATA[Socket]]></category><content:encoded><![CDATA[<h2>2024.09.30 ~ 2024.10.06</h2><h3>🚨 iOS 18 및 Xcode 16 대응</h3><hr /><p>기본적으로 Xcode 16을 사용하기 위해서는 macOS를 Sequoia 15.0으로 업데이트 해야합니다.</p><p>그리고 macOS가 Sequoia인 경우 공식적으로 Xcode 15를 실행할 수 없습니다. (우회적으로는 Xcode 15 앱 → 패키지 내용보기 → Contents → MacOS → Xcode 파일명을 가진 Unix 실행파일을 실행하면 가능합니다.)</p><p>Xcode 16에서는 CocoaPods와 관련된 이슈가 많고, 카카오 SDK도 점차 SwiftPM으로 발전해가는 흐름에 맞춰 SwiftPM으로 이관의 장점이 하나 더 추가된 것 같다.</p><p>iOS 18에서는 UITabBarController의 신규 프로퍼티들이 추가된 영향과 탭의 이동함에 따라 포함되어있는 ViewController들의 생명주기 메서드 호출순서가 다르게 호출되는 부분이 있었다.</p><p>또한, CollectionViewCell을 사용할 때 dequeue를 2번 이상하게되면 앱이 종료되도록 변경되었다.</p><p>운영체제 버전이 올라갈 때는 항상 주의해야겠다.</p><h3>📂 Tuist에서 UnitTest, UITest 타겟 빌드 설정</h3><hr /><p>Tuist로 프로젝트를 관리하는 경우 UnitTest 타겟을 설정하는 경우 Signing 설정에서 Provisioning Profile이 None Required 상태여야 합니다.</p><p>따라서 Code Signing Entitlements를 빈값으로 처리해주면 해결되고, dependencies에 인자로 UnitTest를 지정할 타겟을 추가합니다.</p><p>UITest 타겟은 동일하게 설정하지만 Signing 설정에서 Provisioning Profile은 Xcode Managed Profile로 지정합니다. UnitTest와 차이점은 dependencies에는 UITest를 지정할 타겟과 의존성으로 추가되는 라이브러리도 함께 추가해줘야 빌드가 됩니다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>TCP, UDP Socket과 WebSocket에 대한 개념을 정리해보았는데 더 자세히 정리한 후 Swift로 직접 구현해봐야 겠다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/035-20241007_en</guid><title>Number: 035, Date: 2024-10-07</title><link>https://sookim-1.github.io/en/035-20241007_en</link><description><![CDATA[To use Xcode 16, you must update your macOS to Sequoia 15.0.]]></description><pubDate>Mon, 07 Oct 2024 14:30:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[Tuist]]></category><category><![CDATA[UnitTest]]></category><category><![CDATA[UITest]]></category><category><![CDATA[Socket]]></category><content:encoded><![CDATA[<h2>2024.09.30 ~ 2024.10.06</h2><h3>🚨 iOS 18 and Xcode 16 Compatibility</h3><hr /><p>To use Xcode 16, you must update your macOS to Sequoia 15.0.</p><p>Additionally, when using macOS Sequoia, Xcode 15 cannot be officially launched. (As a workaround, you can run Xcode 15 by going to the Xcode app → Show Package Contents → Contents → MacOS → and executing the Unix file named Xcode.)</p><p>Xcode 16 introduces several issues related to CocoaPods, and as Kakao SDK is progressively transitioning to SwiftPM, it seems that migrating to SwiftPM offers another advantage.</p><p>In iOS 18, new properties were added to <code>UITabBarController</code>, and I observed that the lifecycle methods of the embedded ViewControllers are invoked in a different order when switching between tabs.</p><p>Additionally, if <code>dequeue</code> is called more than twice on a <code>CollectionViewCell</code>, the app now crashes. Always be cautious when updating to a new OS version.</p><h3>📂 Building UnitTest and UITest Targets in Tuist</h3><hr /><p>When managing a project with Tuist, setting up a UnitTest target requires the Provisioning Profile in Signing settings to be set to “None Required.”</p><p>To resolve this, you can set the Code Signing Entitlements to an empty value and add the target you want to specify for UnitTest as an argument in the <code>dependencies</code>.</p><p>For the UITest target, the setup is similar, but the Provisioning Profile in the Signing settings should be set to “Xcode Managed Profile.” The key difference from UnitTest is that you must also add the UITest target and any libraries it depends on to the <code>dependencies</code> to ensure successful builds.</p><h3>🙋🏻‍♂️ Other Notes</h3><hr /><ol><li>I have reviewed the concepts of TCP, UDP Sockets, and WebSockets. I plan to organize this further and implement them directly in Swift.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/034-20240930</guid><title>번호 : 034, 작성일자: 2024-09-30</title><link>https://sookim-1.github.io/ko/034-20240930</link><description><![CDATA[🔗 Ignite는 Swift 개발자들이 Static Website를 만드는데 도움을 주는 라이브러리입니다.]]></description><pubDate>Mon, 30 Sep 2024 13:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[HTTPS]]></category><category><![CDATA[Ignite]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Github]]></category><content:encoded><![CDATA[<h2>2024.09.19 ~ 2024.09.29</h2><h3>🌎 Ignite</h3><hr /><p>🔗 <a href="https://github.com/twostraws/Ignite">Ignite</a>는 Swift 개발자들이 Static Website를 만드는데 도움을 주는 라이브러리입니다.</p><p>저는 주간회고록블로그를 동일한 기능인 🔗 <a href="https://github.com/JohnSundell/Publish">Publish</a> 라이브러리를 사용해서 관리중이였습니다.</p><p>하지만 Publish라이브러리는 커스텀을 자유롭게 하기에는 HTML, CSS 코드에 대한 지식이 필요하지만 Ignite는 SwiftUI형식으로 작성해서 매우 간편하고 직관적이여서 변경을 결심했습니다.</p><p>Ignite의 사용법은 간단했습니다. CLI를 설치한 후 🔗 <a href="https://ignitesamples.hackingwithswift.com/">Sample Site</a>를 참고하여 주어진 Component들을 조합하여 UI를 구현할 수 있습니다.</p><p>Package를 빌드하게 되면 Build 폴더가 생성되는데 해당 폴더내부의 파일들을 배포하면 Static Website가 완성됩니다.</p><p>저는 따로 소스코드를 관리하는 리포지토리를 만든 후 Github action을 사용하여 <a href="http://github.io">github.io</a> 리포지토리로 Build 폴더 내부파일들을 전달하도록 구현했습니다.</p><p>Ignite에는 ContentPreview라는 Component를 제공 중인데 커스텀이 불가능해서 커스텀이 가능하도록 클로저를 전달받도록 오픈소스를 수정했는데 PR 리뷰를 받고 수정자로 전달받도록 구현방식을 제안받아서 재수정했습니다.</p><ul><li>🔗 <a href="https://github.com/twostraws/Ignite/pull/129">Pull Request</a></li></ul><h3>🔐 Github Token 여러 계정관리</h3><hr /><p>🔗 <a href="https://docs.github.com/ko/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-your-personal-account/managing-multiple-accounts">Github Docs - 여러 계정관리</a></p><p>하나의 기기에서 Github의 여러 계정을 관리하기 위해서는 HTTPS 방식에서 따로 처리를 추가해야됩니다.</p><p>HTTPS 방식에서 리포지토리별로 Github Token을 인증받도록하면 계정별로가 아닌 리포지토리별로 인증을 하기 때문에 해결되지만 키체인에 여러개가 쌓이게 되고 리포지토리별로 매번 인증해야해서 번거롭기 때문에 SSH방식을 사용하는 것이 나은 것 같습니다.</p><blockquote><p>HTTPS 방식 여러 계정 관리</p></blockquote><pre><code class="language-bash">$ git config --get credential.helper

# Enter
$ git credential-osxkeychain erase
host=github.com
protocol=https

$ git config --global credential.https://github.com.useHttpPath true
</code></pre><blockquote><p>SSH 방식 여러 계정 관리</p></blockquote><pre><code class="language-bash"># 각 계정마다 SSH 키 생성
$ ssh-keygen -t ed25519 -C "your_email@example.com"

# SSH설정파일 작성 
$ ~/.ssh/config

#############
Host github-personal
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519_personal

Host github-work
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519_work
#############

# 각 리포지토리마다 다른 호스트 이름을 사용하여 클론
git clone git@github-personal:username/repo.git
git clone git@github-work:username/repo.git
</code></pre><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>macOS Sequoia 15, Xcode 16으로 업그레이드를 한 후 에 HandyJSON이 빌드가 되지 않는 이슈가 있습니다. 해당 이슈를 수정한 branch가 있어서 해당 branch로 SwiftPM에 추가하면 해결됩니다.</li><li>Xcode 16에서 code completion이 강화되었는데 제시된 코드제안을 작성하려면 Tap버튼을 클릭합니다.</li><li>Facebook Login SDK에 대한 Reject을 받았는데 매번 느끼지만 Facebook에 대한 해결팁은 일단 여러번 제출해야 자세한 이유를 알려주는 것 같다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/034-20240930_en</guid><title>Number: 034, Date: 2024-09-30</title><link>https://sookim-1.github.io/en/034-20240930_en</link><description><![CDATA[🔗 Ignite is a library that helps Swift developers create static websites.]]></description><pubDate>Mon, 30 Sep 2024 13:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[HTTPS]]></category><category><![CDATA[Ignite]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Github]]></category><content:encoded><![CDATA[<h2>2024.09.19 ~ 2024.09.29</h2><h3>🌎 Ignite</h3><hr /><p>🔗 <a href="https://github.com/twostraws/Ignite">Ignite</a> is a library that helps Swift developers create static websites.</p><p>I have been managing my weekly retrospective blog using a similar library called 🔗 <a href="https://github.com/JohnSundell/Publish">Publish</a>.</p><p>However, while Publish requires knowledge of HTML and CSS for customizations, Ignite is much more intuitive and simple, using SwiftUI-like syntax, which led me to switch.</p><p>Ignite is easy to use. After installing the CLI, you can implement the UI by combining the provided components, referencing the 🔗 <a href="https://ignitesamples.hackingwithswift.com/">Sample Site</a>.</p><p>When you build the package, a Build folder is created. By deploying the files inside that folder, a static website is complete.</p><p>I created a separate repository to manage the source code, then implemented a GitHub action to transfer the files from the Build folder to my <a href="http://github.io">github.io</a> repository.</p><p>Ignite provides a component called ContentPreview, but it’s not customizable. I modified the open source to accept a closure for customization, but after a PR review, I was advised to pass it to the modifier and revised the implementation accordingly.</p><ul><li>🔗 <a href="https://github.com/twostraws/Ignite/pull/129">Pull Request</a></li></ul><h3>🔐 Managing Multiple GitHub Accounts with Tokens</h3><hr /><p>🔗 <a href="https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-your-personal-account/managing-multiple-accounts">GitHub Docs - Managing Multiple Accounts</a></p><p>To manage multiple GitHub accounts on a single device, some additional steps are required when using the HTTPS method.</p><p>While using GitHub tokens for each repository can solve the issue by authenticating at the repository level instead of the account level, it results in multiple entries in the keychain and requires authentication for each repository, which can be inconvenient. Using SSH seems to be a better approach.</p><blockquote><p>Managing Multiple Accounts with HTTPS</p></blockquote><pre><code class="language-bash">$ git config --get credential.helper

# Enter
$ git credential-osxkeychain erase
host=github.com
protocol=https

$ git config --global credential.https://github.com.useHttpPath true
</code></pre><blockquote><p>Managing Multiple Accounts with SSH</p></blockquote><pre><code class="language-bash"># Generate SSH keys for each account
$ ssh-keygen -t ed25519 -C "your_email@example.com"

# Create SSH config file
$ ~/.ssh/config

#######
Host github-personal
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519_personal

Host github-work
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519_work
#######

# Use different hostnames for each repository when cloning
git clone git@github-personal:username/repo.git
git clone git@github-work:username/repo.git
</code></pre><h3>🙋🏻‍♂️ Miscellaneous</h3><hr /><ol><li>After upgrading to macOS Sequoia 15 and Xcode 16, there is an issue where HandyJSON fails to build. There is a branch that fixes this issue, and adding that branch to SwiftPM resolves it.</li><li>Code completion in Xcode 16 has been enhanced. To apply the suggested code, click the Tab button.</li><li>I received a rejection regarding the Facebook Login SDK. As usual with Facebook, it seems that submitting multiple times is necessary to get a detailed reason for the rejection.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/033-20240919</guid><title>번호 : 033, 작성일자: 2024-09-19</title><link>https://sookim-1.github.io/ko/033-20240919</link><description><![CDATA[지난 주 YesWeScan라이브러리에서만 인식률이 좋았던 이유에 대해서 분석해본 결과 전달받은 AVCapturePhoto를 UIImage로 타입캐스팅한 결과 인식률이 좋지 않았고 CMSampleBufffer를 CIImage로 타입캐스팅하여 사용해야 인식률이 좋았다.]]></description><pubDate>Thu, 19 Sep 2024 15:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[접근권한]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[정규표현식]]></category><category><![CDATA[SnapKit]]></category><category><![CDATA[CodingTest]]></category><category><![CDATA[Youtube]]></category><category><![CDATA[Vision]]></category><content:encoded><![CDATA[<h2>2024.09.09 ~ 2024.09.18</h2><h3>📷 Text OCR</h3><hr /><p>지난 주 YesWeScan라이브러리에서만 인식률이 좋았던 이유에 대해서 분석해본 결과 전달받은 AVCapturePhoto를 UIImage로 타입캐스팅한 결과 인식률이 좋지 않았고 CMSampleBufffer를 CIImage로 타입캐스팅하여 사용해야 인식률이 좋았다.</p><p>추가로 직접 캡처동작을 트리거하지 않고 매 프레임을 입력받아 자동으로 텍스트가 인식되면 처리하기 위해 고민해본 결과 AVCapturePhoto를 사용하지 않고 AVCaptureVideo를 사용하면 매 프레임을 입력받고 입력받은 CMSampleBuffer를 CIImage로 타입캐스팅 후 Vision을 통해 텍스트를 인식하게 되면 자동으로 텍스트가 인식된 경우를 처리할 수 있었다.</p><h3>🌎 Youtube Data API 활용 - 재생목록 내의 동영상목록 가져오기</h3><hr /><p>지난 주 Youtube 특정채널 동영상목록을 가져오는 파이썬 스크립트를 작성했다.</p><p>특정채널 동영상목록이 매우 많은 경우 무료 API 제한량이 있어서 딜레이를 지정해도 모든 동영상을 가져오지 못하는 경우도 있고, 재생목록내의 동영상이 따로 있는 경우도 있어서 재생목록 내의 동영상목록을 가져오는 파이썬 스크립트를 추가작성했다.</p><p>🔗 <a href="https://developers.google.com/youtube/v3/docs/playlistItems/list?hl=ko">Youtube API Docs - playlistitem</a></p><pre><code class="language-python">import requests
import time

# Step 1: API 설정
API_KEY = ''  # 실제 API 키 작성
PLAYLIST_ID = '' # 재생목록 ID
CHANNEL_ID = ''  # 제목을 가져올 채널 ID

MAX_RESULTS = 50  # 한 번에 가져올 결과 수 (최대 50)

# 유튜브 데이터 API v3 playlistItems 엔드포인트 기본 URL
youtube_url = 'https://www.googleapis.com/youtube/v3/playlistItems'

# API 요청에 필요한 매개변수
params = {
    'part': 'snippet',
    'maxResults': MAX_RESULTS,
    'playlistId': PLAYLIST_ID,
    'key': API_KEY
}

# 재생목록에서 비디오 제목과 URL을 가져오는 함수
def fetch_playlist_video_titles_and_urls():
    videosResult = []
    next_page_token = None
    index = 1  # 동영상 인덱스 시작값

    while True:
        if next_page_token:
            params['pageToken'] = next_page_token

        # Step 2: 유튜브 데이터 API에 GET 요청 보내기
        response = requests.get(youtube_url, params=params)
        data = response.json()

        # Step 3: 비디오 제목 및 URL 추출
        for item in data['items']:
            title = item['snippet']['title']
            video_id = item['snippet']['resourceId']['videoId']
            video_url = f'https://www.youtube.com/watch?v={video_id}&list={PLAYLIST_ID}&index={index}'
            videosResult.append((title, video_url))
            index += 1

        # 다음 페이지가 있는지 확인
        next_page_token = data.get('nextPageToken')

        # 다음 페이지가 있을 경우, 61초 대기
        if not next_page_token:
            break

    return videosResult

# 제목과 URL을 텍스트 파일에 저장하는 함수
def save_titles_and_urls_to_file(videos, filename='playlist_video_titles_and_urls.txt'):
    with open(filename, 'w', encoding='utf-8') as file:
        for index, (title, url) in enumerate(videos, start=1):
            file.write(f"{index}. **[{title}]({url})**\n\n")

# 코드 실행
videos = fetch_playlist_video_titles_and_urls()
save_titles_and_urls_to_file(videos)
</code></pre><ul><li>원하는 채널ID를 검색한 후 다음페이지가 있다면 페이지를 검색하여 동영상목록을 가져온 후 playlist_video_titles_and_urls.txt파일에 저장하는 스크립트</li></ul><h3>👨‍🎓 AutorizationStatus 정리</h3><hr /><p>iOS에서는 몇몇 시스템을 사용하기 위해서는 접근권한등이 필요합니다. 예를 들어, 위치권한이 필요한 경우 위치정보에 접근할 수 있는 권한이 필요합니다.</p><p>접근권한의 상태등을 알 수 있는 방법은 AuthorizationStatus라는 enum객체를 사용할 수 있습니다.</p><p>위치접근권한은 CLAuthorizationStatus로 case가 약간 다르지만 대부분의 case들의 종류는 3가지 (<code>Authorized</code> , <code>Denied</code>  , <code>NotDetermined</code> )를 자주 사용합니다.</p><ul><li><code>Authorized</code> : 권한이 허용된 상태</li><li><code>Denied</code> : 권한이 거부된 상태</li><li><code>NotDetermined</code> : 권한허용여부를 물어보지 않은 상태</li></ul><p>그럼 notDetermined는 권한허용여부를 물어보지 않은 상태인데 앱이 처음 시작할 때 무조건 권한허용여부를 물어본 상태에도 가끔씩 notDetermined로 설정된 경우가 있을 수 있는 부분이 있어서 의아해서 검색해보았지만 오류가 발생할 수 있다는 내용만 찾았다.</p><p>권한요청을 하는 클로저내에서 UI관련 작업들은 메인스레드를 주의해서 사용할 필요가 있다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>Xcode 16이 발표되면서 이전 버전들의 차이점이 궁금해서 간단히 찾아보았는데 iOS보다 Xcode가 먼저 발표되었고 macOS전용이라는 부분등이 신기했다.</li><li>정규식 간단하게 사용하는 방법 <code>[A-Z0-91{2}_[A-Z0-9]{2}_[A-Z0-9]{2}</code> 와 <code>([A-Z0-9]{2}_){2}[A-Z0-9]{2}</code> 는 동일하다.</li><li>SnapKit으로 레이아웃을 구현하는 경우 키보드가 올라올 때 애니메이션 처리하는 방법<pre><code class="language-swift">@objc func keyboardWillShow(note: NSNotification) {
    if let keyboardSize = (note.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
        var keyboardHeight = CGFloat(Int(keyboardSize.height))
        
        self.scrollView.snp.updateConstraints {
            $0.bottom.equalToSuperView().offset(-keyboardHeight)
        }

        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {
            self.view.layoutIfNeeded()
        }, completion: nil)
    }
}
</code></pre></li><li>Xcode 단축키를 정리했다.</li><li>Kavsoft라는 SwiftUI를 잘 정리한 사이트가 있어서 해당 채널을 보며 정리했다.</li><li>프로그래머스 코딩테스트 0단계 중 자주 사용하지 않았던 메서드들을 정리 했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/033-20240919_en</guid><title>Number: 033, Date: 2024-09-19</title><link>https://sookim-1.github.io/en/033-20240919_en</link><description><![CDATA[Last week, after analyzing the reasons for the high recognition rate with the YesWeScan library, it turned out that the recognition rate was poor when casting AVCapturePhoto to UIImage, but it improved significantly when using CMSampleBuffer cast to CIImage.]]></description><pubDate>Thu, 19 Sep 2024 15:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[access permission]]></category><category><![CDATA[Xcode]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[regex]]></category><category><![CDATA[SnapKit]]></category><category><![CDATA[CodingTest]]></category><category><![CDATA[Youtube]]></category><category><![CDATA[Vision]]></category><content:encoded><![CDATA[<h2>2024.09.09 ~ 2024.09.18</h2><h3>📷 Text OCR</h3><hr /><p>Last week, after analyzing the reasons for the high recognition rate with the YesWeScan library, it turned out that the recognition rate was poor when casting AVCapturePhoto to UIImage, but it improved significantly when using CMSampleBuffer cast to CIImage.</p><p>Additionally, to handle automatic text recognition without manually triggering capture actions, I found that by using AVCaptureVideo instead of AVCapturePhoto, I could input each frame and cast the received CMSampleBuffer to CIImage. This way, text recognition through Vision could automatically process cases when text was recognized.</p><h3>🌎 YouTube Data API Utilization - Fetching Videos from Playlist</h3><hr /><p>Last week, I wrote a Python script to fetch video lists from a specific YouTube channel.</p><p>When the number of videos from a specific channel is very large, there are limits on the free API usage, so even if a delay is specified, it may not fetch all videos. Additionally, if there are separate videos in a playlist, I also created a script to fetch the video list from the playlist.</p><p>🔗 <a href="https://developers.google.com/youtube/v3/docs/playlistItems/list?hl=ko">YouTube API Docs - playlistitem</a></p><pre><code class="language-python">import requests
import time

# Step 1: API Settings
API_KEY = ''  # Enter your actual API key here
PLAYLIST_ID = ''  # Playlist ID
CHANNEL_ID = ''  # Channel ID to fetch titles from

MAX_RESULTS = 50  # Maximum number of results to fetch at once (up to 50)

# Base URL for YouTube Data API v3 playlistItems endpoint
youtube_url = 'https://www.googleapis.com/youtube/v3/playlistItems'

# Parameters required for the API request
params = {
    'part': 'snippet',
    'maxResults': MAX_RESULTS,
    'playlistId': PLAYLIST_ID,
    'key': API_KEY
}

# Function to fetch video titles and URLs from the playlist
def fetch_playlist_video_titles_and_urls():
    videosResult = []
    next_page_token = None
    index = 1  # Starting index for videos

    while True:
        if next_page_token:
            params['pageToken'] = next_page_token

        # Step 2: Send GET request to YouTube Data API
        response = requests.get(youtube_url, params=params)
        data = response.json()

        # Step 3: Extract video titles and URLs
        for item in data['items']:
            title = item['snippet']['title']
            video_id = item['snippet']['resourceId']['videoId']
            video_url = f'https://www.youtube.com/watch?v={video_id}&list={PLAYLIST_ID}&index={index}'
            videosResult.append((title, video_url))
            index += 1

        # Check if there's a next page
        next_page_token = data.get('nextPageToken')

        # Wait 61 seconds if there's a next page
        if not next_page_token:
            break

    return videosResult

# Function to save titles and URLs to a text file
def save_titles_and_urls_to_file(videos, filename='playlist_video_titles_and_urls.txt'):
    with open(filename, 'w', encoding='utf-8') as file:
        for index, (title, url) in enumerate(videos, start=1):
            file.write(f"{index}. **[{title}]({url})**\n\n")

# Execute the code
videos = fetch_playlist_video_titles_and_urls()
save_titles_and_urls_to_file(videos)
</code></pre><ul><li>A script that retrieves the list of videos by searching for the desired channel ID and, if there are more pages, searches for the next page to save the video list to the <code>playlist_video_titles_and_urls.txt</code> file.</li></ul><h3>👨‍🎓 AuthorizationStatus Overview</h3><hr /><p>In iOS, some systems require permission to access certain features. For example, if location permission is needed, you must have permission to access location information.</p><p>You can determine the status of permissions using an enum object called <code>AuthorizationStatus</code>.</p><p>For location access, it varies slightly with <code>CLAuthorizationStatus</code>, but most cases fall into three categories that are frequently used: (<code>Authorized</code>, <code>Denied</code>, <code>NotDetermined</code>).</p><ul><li><code>Authorized</code>: Permission has been granted.</li><li><code>Denied</code>: Permission has been denied.</li><li><code>NotDetermined</code>: Permission has not yet been asked.</li></ul><p>The <code>NotDetermined</code> state indicates that permission has not been requested. However, there can be instances where it remains <code>NotDetermined</code> even after the app prompts for permission when it first starts, which was puzzling, and I found only information about potential errors when searching.</p><p>When making permission requests in a closure, it is important to ensure that UI-related tasks are performed on the main thread.</p><h3>🙋🏻‍♂️ Other Notes</h3><hr /><ol><li>After the announcement of Xcode 16, I was curious about the differences from previous versions and found it interesting that Xcode was announced before iOS and is exclusive to macOS.</li><li>A simple way to use regular expressions is that <code>[A-Z0-91{2}_[A-Z0-9]{2}_[A-Z0-9]{2}</code> and <code>([A-Z0-9]{2}_){2}[A-Z0-9]{2}</code> are identical.</li><li>How to handle animations when the keyboard appears while implementing layouts with SnapKit.<pre><code class="language-swift">@objc func keyboardWillShow(note: NSNotification) {
    if let keyboardSize = (note.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
        var keyboardHeight = CGFloat(Int(keyboardSize.height))
        
        self.scrollView.snp.updateConstraints {
            $0.bottom.equalToSuperView().offset(-keyboardHeight)
        }

        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {
            self.view.layoutIfNeeded()
        }, completion: nil)
    }
}
</code></pre></li><li>I organized Xcode shortcuts.</li><li>I found a well-organized site on SwiftUI called Kavsoft and organized my notes using that channel.</li><li>I organized methods that were not frequently used in the level 0 coding test on Programmers.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/032-20240909</guid><title>번호 : 032, 작성일자: 2024-09-09</title><link>https://sookim-1.github.io/ko/032-20240909</link><description><![CDATA[기존 UIKit 프로젝트에서 SwiftUI + TCA를 적용한 화면을 적용하기 위해 개발을 했다.]]></description><pubDate>Mon, 09 Sep 2024 19:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[TCA]]></category><category><![CDATA[URLSession]]></category><category><![CDATA[Vision]]></category><category><![CDATA[OCR]]></category><category><![CDATA[Youtube]]></category><content:encoded><![CDATA[<h2>2024.09.03 ~ 2024.09.08</h2><h3>🏬 SwiftUI + TCA (The Composable Architecture)</h3><hr /><p>기존 UIKit 프로젝트에서 SwiftUI + TCA를 적용한 화면을 적용하기 위해 개발을 했다.</p><p>일단 SwiftUI를 사용하며 느끼는 점은 편리한 부분이 많다는 점이였다.</p><p>UIComponent를 분리 작업, SwiftUI 코드가 UIKit보다 코드 줄이 적어서 가독성이 좋았고, ChatGPT 활용도, Preview 속도등 UI 개발시간이 단축되는 느낌이다.</p><p>TCA는 API 처리 할 때 request, response등 Action이 2개 이상 추가해야해서 조건이 많지 않을 까 생각해봤는데 해당 아키텍처라이브러리에서 단방향을 지키기 위한 부분이라고 생각했다.</p><h3>📷 Text OCR</h3><hr /><p>사진에서 Text를 추출하기 위해서 여러가지 Tool이 있다.(Google ML Kit, NHNCloud OCR, Vision)</p><p>그 중 Vision 프레임워크는 Apple에서 제공하는 프레임워크여서 해당 프레임워크를 사용해서 텍스트추출을 시도해봤다.</p><p>이름이 비슷한 VisionKit프레임워크도 있는데, 해당 프레임워크를 같이 사용하면 VNDocumentCameraViewController를 사용하여 영역을 인식해주고 이미지를 추출하면 Vision프레임워크를 이용해 해당 이미지에서 텍스트를 추출할 수 있다.</p><p>하지만, 카메라 스캔화면을 Custom하기 위해서는 직접 VNDocumentCameraViewController를 Custom하는 방법은 아직 없는 것 같다.</p><p>그래서 AVFoundation프레임워크를 활용하여 카메라를 캡처한후 이미지를 Vision프레임워크에 제공했는데 인식률이 현저히 떨어졌다.</p><p>VisionKit이 제공되지 않았을 때 자주 사용하던 🔗 <a href="https://github.com/adorsys/YesWeScan">YesWeScan라이브러리</a>가 있다고 해서 이미지를 제공하여 테스트해보았는데 VisionKit과 인식률이 동일했다.</p><p>해당 라이브러리를 분석하여 내가 첫번째로 사용했던 AVFoundation에서 설정하는 부분에서 차이점을 찾아보고 확인해봐야겠다.</p><h3>🌎 Youtube Data API 활용</h3><hr /><p>개발과 관련된 유용한 Youtube채널의 영상들의 시청여부를 저장하기 위해 Youtube Data API를 활용해서 재생목록을 텍스트파일로 정리해주는 파이썬스크립트를 작성했다.</p><p>🔗 <a href="https://developers.google.com/youtube/v3/docs/search/list?hl=ko">Youtube API Docs - search</a></p><pre><code class="language-python">import requests
import time

# Step 1: API 설정
API_KEY = ''  # 실제 API 키 작성
CHANNEL_ID = ''  # 제목을 가져올 채널 ID

MAX_RESULTS = 50  # 한 번에 가져올 결과 수 (최대 50)

# 유튜브 데이터 API v3 검색 엔드포인트 기본 URL
youtube_url = 'https://www.googleapis.com/youtube/v3/search'

# API 요청에 필요한 매개변수
params = {
    'part': 'snippet',
    'maxResults': MAX_RESULTS,
    'channelId': CHANNEL_ID,
    'type': 'video',
    'order': 'date',  # 결과를 날짜순으로 정렬
    'key': API_KEY
}

# 비디오 제목과 URL을 가져오는 함수
def fetch_video_titles_and_urls():
    videosResult = []
    next_page_token = None

    while True:
        if next_page_token:
            params['pageToken'] = next_page_token

        # Step 2: 유튜브 데이터 API에 GET 요청 보내기
        response = requests.get(youtube_url, params=params)
        data = response.json()

        # Step 3: 비디오 제목 및 URL 추출
        for item in data['items']:
            title = item['snippet']['title']
            video_id = item['id']['videoId']
            video_url = f'https://www.youtube.com/watch?v={video_id}'
            videosResult.append((title, video_url))

        # 다음 페이지가 있는지 확인
        next_page_token = data.get('nextPageToken')

        # 다음 페이지가 있을 경우, 61초 대기
        if next_page_token:
            time.sleep(61)

        if not next_page_token:
            break

    return videosResult

# 제목과 URL을 텍스트 파일에 저장하는 함수
def save_titles_and_urls_to_file(videos, filename='video_titles_and_urls.txt'):
    with open(filename, 'w', encoding='utf-8') as file:
        for index, (title, url) in enumerate(videos, start=1):
            file.write(f"{index}. {title}\n- {url}\n\n")

# 코드 실행
videos = fetch_video_titles_and_urls()
save_titles_and_urls_to_file(videos)

</code></pre><ul><li>원하는 채널ID를 검색한 후 다음페이지가 있다면 페이지를 검색하여 동영상목록을 가져온 후 video_titles_and_urls.txt파일에 저장하는 스크립트</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>URLComponents에 queryItem에 추가하면 자동으로 UTF-8형식 URL인코딩을 자동으로 해주기 때문에 따로 처리하면 중복 인코딩이 될 수 있다.<pre><code class="language-swift">    func requestSearch(keyword: String) async throws -> Result<SampleDTO, SampleError> {
				...
				
        /* 중복
        guard let encodedKeyword = keyword.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
            return .failure(.invalidUrl)
        }
        */

        // query에 넣으면 자동으로 URL Encoding함
        components?.queryItems = [
            URLQueryItem(name: "searchKeyword", value: keyword)
        ]
        
        ...
</code></pre></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/032-20240909_en</guid><title>Number: 032, Date: 2024-09-09</title><link>https://sookim-1.github.io/en/032-20240909_en</link><description><![CDATA[I developed a screen applying SwiftUI + TCA in an existing UIKit project.]]></description><pubDate>Mon, 09 Sep 2024 19:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[TCA]]></category><category><![CDATA[URLSession]]></category><category><![CDATA[Vision]]></category><category><![CDATA[OCR]]></category><category><![CDATA[Youtube]]></category><content:encoded><![CDATA[<h2>2024.09.03 ~ 2024.09.08</h2><h3>🏬 SwiftUI + TCA (The Composable Architecture)</h3><hr /><p>I developed a screen applying SwiftUI + TCA in an existing UIKit project.</p><p>One major takeaway from using SwiftUI is its many conveniences. The separation of UI components and the reduced number of lines of code compared to UIKit enhance readability. I also noticed that utilizing ChatGPT and the speed of Preview significantly shortened the UI development time.</p><p>When handling API requests with TCA, I initially thought that having multiple Actions (e.g., request, response) might complicate things, but I see it as a measure to maintain unidirectional data flow within the architecture.</p><h3>📷 Text OCR</h3><hr /><p>There are various tools for extracting text from images (Google ML Kit, NHNCloud OCR, Vision).</p><p>Among them, I decided to use the Vision framework, which is provided by Apple, for text extraction.</p><p>There’s a similarly named framework, VisionKit, which can be used together to recognize areas using <code>VNDocumentCameraViewController</code> and extract images for text extraction via the Vision framework.</p><p>However, it seems there isn’t a way to customize the camera scan screen directly with <code>VNDocumentCameraViewController</code>.</p><p>So, I used the AVFoundation framework to capture images and provided them to the Vision framework, but the recognition rate was significantly lower.</p><p>I tested the 🔗 <a href="https://github.com/adorsys/YesWeScan">YesWeScan library</a>, which I used frequently before VisionKit was available, and found that its recognition rate was comparable to that of VisionKit.</p><p>I plan to analyze the library to identify differences in the configuration when using AVFoundation, which I initially set up.</p><h3>🌎 Using YouTube Data API</h3><hr /><p>To track the viewing status of useful YouTube channel videos related to development, I wrote a Python script that organizes playlists into a text file using the YouTube Data API.</p><p>🔗 <a href="https://developers.google.com/youtube/v3/docs/search/list?hl=ko">YouTube API Docs - search</a></p><pre><code class="language-python">import requests
import time

# Step 1: API settings
API_KEY = ''  # Enter your actual API key here
CHANNEL_ID = ''  # Enter the channel ID from which to fetch titles

MAX_RESULTS = 50  # Maximum number of results to retrieve at once (up to 50)

# YouTube Data API v3 search endpoint base URL
youtube_url = 'https://www.googleapis.com/youtube/v3/search'

# Parameters needed for the API request
params = {
    'part': 'snippet',
    'maxResults': MAX_RESULTS,
    'channelId': CHANNEL_ID,
    'type': 'video',
    'order': 'date',  # Sort results by date
    'key': API_KEY
}

# Function to fetch video titles and URLs
def fetch_video_titles_and_urls():
    videosResult = []
    next_page_token = None

    while True:
        if next_page_token:
            params['pageToken'] = next_page_token

        # Step 2: Send GET request to YouTube Data API
        response = requests.get(youtube_url, params=params)
        data = response.json()

        # Step 3: Extract video titles and URLs
        for item in data['items']:
            title = item['snippet']['title']
            video_id = item['id']['videoId']
            video_url = f'https://www.youtube.com/watch?v={video_id}'
            videosResult.append((title, video_url))

        # Check if there is a next page
        next_page_token = data.get('nextPageToken')

        # Wait for 61 seconds if there is a next page
        if next_page_token:
            time.sleep(61)

        if not next_page_token:
            break

    return videosResult

# Function to save titles and URLs to a text file
def save_titles_and_urls_to_file(videos, filename='video_titles_and_urls.txt'):
    with open(filename, 'w', encoding='utf-8') as file:
        for index, (title, url) in enumerate(videos, start=1):
            file.write(f"{index}. {title}\n- {url}\n\n")

# Execute the code
videos = fetch_video_titles_and_urls()
save_titles_and_urls_to_file(videos)

</code></pre><ul><li>A script that searches for the desired channel ID, fetches the video list, and saves it to the <code>video_titles_and_urls.txt</code> file if there is a next page.</li></ul><h3>🙋🏻‍♂️ Other Notes</h3><hr /><ol><li>When adding to <code>queryItem</code> in <code>URLComponents</code>, it automatically performs UTF-8 URL encoding, so handling it separately may result in double encoding.<pre><code class="language-swift">    func requestSearch(keyword: String) async throws -> Result<SampleDTO, SampleError> {
				...
				
        /* Duplicate
        guard let encodedKeyword = keyword.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
            return .failure(.invalidUrl)
        }
        */

        // Automatically performs URL encoding when added to the query
        components?.queryItems = [
            URLQueryItem(name: "searchKeyword", value: keyword)
        ]
        
        ...
</code></pre></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/031-20240903</guid><title>번호 : 031, 작성일자: 2024-09-03</title><link>https://sookim-1.github.io/ko/031-20240903</link><description><![CDATA[🔗 pointfreeco - Tutorial]]></description><pubDate>Tue, 03 Sep 2024 18:44:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[TCA]]></category><category><![CDATA[SwiftPM]]></category><category><![CDATA[UnitTest]]></category><category><![CDATA[Tuist]]></category><category><![CDATA[Fastlane]]></category><content:encoded><![CDATA[<h2>2024.08.27 ~ 2024.09.02</h2><h3>🏬 TCA (The Composable Architecture)</h3><hr /><ul><li>🔗 <a href="https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/">pointfreeco - Tutorial</a></li></ul><p>해당 Tutorial은 TCA 라이브러리를 만든 pointfreeco에서 제공하는 Tutorial인데 처음 TCA를 시작하기 좋아서 정리하면서 사용방법에 대해서 알아보았다.</p><p>TCA는 아키텍처를 구현하는데 도움을 주는 라이브러리이기 때문에 라이브러리를 추가했다. 라이브러리를 설치한 후 빌드시간을 봤는데 매우 증가되었다. 일단 검색해본 결과 Apple 측에서 Swift Syntax 컴파일시간이 늘어나서 오래걸린다고 하는 것 같다.</p><p>TCA와 SwiftUI를 같이 사용하는 경우 View에 Store를 연결한 후 Action을 입력받아 State를 변경하는 방식이였다.</p><p>Action을 입력받아 State를 변경하는 객체는 Reducer 프로토콜을 준수하는 Feature에서 담당한다.</p><p>TCA를 배우면서 느낀점은 사실상 크게 보면 View와 Feature만 나눠져있어서 Feature가 MVC의 Controller나 MVVM의 ViewModel 처럼 무거워지지 않을까 생각했는데 Feature를 더 작게 나눈 후 통합하는 부분이 자연스러웠고 Swift Macro가 구현이 잘되어 있어서 일단 깔끔했던 것 같다.</p><p>그리고 Unit테스트를 진행할 때 Feature만 테스트를 진행하면 되고 TestStore를 비롯해 여러 테스트도구도 제공하기 때문에 테스트코드 작성이 매우 편리했다.</p><h3>🎨 Design System</h3><hr /><p>개인적으로 사용하는 DesignSystem을 여러 Target으로 나누었을 때 비공개 Spec 저장소 하나에서 올리고 싶어서 SwiftUI Target을 추가했다.</p><p>라이브러리의 버전을 올릴 때 podspec파일들을 찾아서 version을 올려주는 쉘스크립트파일을 작성했고 해당 실행이 완료되면 workflow가 돌아서 tag 버전도 올리는 파일을 작성했지만 Linux에서 이슈가 있어서 일단 쉘스크립트파일에서 tag 버전까지 올리도록 임시로 설정했다.</p><h3>🚨 Tuist와 Fastlane을 사용할 때 관련된 이슈</h3><hr /><p>전처리문 조건문에서 Build Configuration이 제대로 분기처리 되지 않는 이슈</p><ul><li>xcconfig파일에서 OTHER_SWIFT_FLAGS[config=Release]=$(inherited) -D RELEASE 처럼 조건부컴파일을 위한 플래그를 설정해주는 -D 플래그 설정이 되지 않았던 문제</li><li>-D 플래그에 설정한 문자열을 전처리문 조건문에서 사용할 수 있다.</li></ul><p>Tuist를 적용하면서 fastlane 배포 후 버전업데이트를 xcode프로젝트에만 적용해서 버전이 맞춰지지 않는 이슈</p><ul><li>fastlane에서 xcode프로젝트 버전업데이트 해주는 lane이 존재하지만 xcconfig도 변경해주기 위해서 🔗 <a href="https://github.com/sovcharenko/fastlane-plugin-xcconfig">fastlane-plugin-xcconfig</a>을 활용해서 Marketing Version, Current Project Version을 수정해주는 lane을 쉽게 작성할 수 있다.</li></ul><p>fastlane에서 get_build_number를 가져오지 못하는 이슈</p><ul><li>$ agvtool what-version를 실행할 때 불러오지 못하는 경우 Build Setting에서 Versioning System - AppleGeneric으로 변경한다.</li><li>변경해도 안되는 경우 버전을 변경하면 인식하는데 첫 xcode 프로젝트 생성할 때 인식을 못하면 Tuist에서 Setting할 때 Current Project Version을 1로 설정후 생성한다.</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>UnitTest를 SwiftPM사용하는 경우 본 Target을 추가하면 자동으로 의존성들이 같이 추가되기 때문에 CocoaPods처럼 Test 타겟에서 따로 설치할 필요가 없다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/031-20240903_en</guid><title>Number: 031, Date: 2024-09-03</title><link>https://sookim-1.github.io/en/031-20240903_en</link><description><![CDATA[🔗 pointfreeco - Tutorial]]></description><pubDate>Tue, 03 Sep 2024 18:44:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[TCA]]></category><category><![CDATA[SwiftPM]]></category><category><![CDATA[UnitTest]]></category><category><![CDATA[Tuist]]></category><category><![CDATA[Fastlane]]></category><content:encoded><![CDATA[<h2>2024.08.27 ~ 2024.09.02</h2><h3>🏬 TCA (The Composable Architecture)</h3><hr /><ul><li>🔗 <a href="https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/">pointfreeco - Tutorial</a></li></ul><p>This tutorial is provided by pointfreeco, the creators of the TCA library, and it’s great for getting started with TCA. I organized my findings while exploring how to use it.</p><p>TCA is a library that helps implement architecture, so I added it to my project. After installing the library, I noticed a significant increase in build time. Upon researching, it seems that Apple mentioned an increase in Swift Syntax compilation time, which can lead to longer build durations.</p><p>When using TCA with SwiftUI, the Store is connected to the View, and it receives Actions to modify the State.</p><p>The object that changes the State upon receiving Actions is managed by a Feature that conforms to the Reducer protocol.</p><p>From my experience learning TCA, I initially thought it might end up heavy like the Controller in MVC or ViewModel in MVVM because it primarily separates View and Feature. However, I found it natural to break down Features into smaller parts and integrate them. Swift Macros are well-implemented, which contributes to the overall neatness of the structure.</p><p>Additionally, while conducting Unit tests, it was easy to test just the Features, and tools like TestStore make writing test code very convenient.</p><h3>🎨 Design System</h3><hr /><p>I wanted to split my personal Design System into multiple Targets and host it in a private Spec repository, so I added a SwiftUI Target.</p><p>I wrote a shell script to find and update the versions in the podspec files when raising the library’s version. After the script runs, a workflow triggers to also update the tag version. However, I encountered issues on Linux, so for now, I temporarily configured the shell script to update the tag version directly.</p><h3>🚨 Issues with Tuist and Fastlane</h3><hr /><p>There was an issue where the conditional compilation didn’t correctly branch for the Build Configuration in the preprocessor directives.</p><ul><li>The problem arose because the -D flag for conditional compilation was not set properly in the xcconfig file: <code>OTHER_SWIFT_FLAGS[config=Release]=$(inherited) -D RELEASE</code>.</li><li>You can use the strings set by the -D flag in the preprocessor directives.</li></ul><p>While applying Tuist, there was an issue where after Fastlane deployment, the version update was only applied to the Xcode project, leading to version mismatches.</p><ul><li>Fastlane has a lane for updating the Xcode project version, but to also change the xcconfig, you can easily write a lane using the 🔗 <a href="https://github.com/sovcharenko/fastlane-plugin-xcconfig">fastlane-plugin-xcconfig</a> to modify the Marketing Version and Current Project Version.</li></ul><p>There was also an issue where Fastlane couldn’t retrieve the build number.</p><ul><li>If <code>$ agvtool what-version</code> fails to retrieve the version, change the Versioning System in Build Settings to AppleGeneric.</li><li>If it still doesn’t work, changing the version often triggers recognition, but if it wasn’t recognized when creating the Xcode project, set the Current Project Version to 1 during Tuist setup.</li></ul><h3>🙋🏻‍♂️ Other Matters</h3><hr /><ol><li>When using UnitTest with SwiftPM, adding the main Target automatically brings in the dependencies, eliminating the need for separate installations in the Test Target like CocoaPods.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/030-20240827</guid><title>번호 : 030, 작성일자: 2024-08-27</title><link>https://sookim-1.github.io/ko/030-20240827</link><description><![CDATA[🔗 Swifter for SwiftUI]]></description><pubDate>Tue, 27 Aug 2024 12:10:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[SwiftPM]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Supabase]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[TCA]]></category><category><![CDATA[Git]]></category><category><![CDATA[Github]]></category><category><![CDATA[Firebase]]></category><category><![CDATA[접근권한]]></category><content:encoded><![CDATA[<h2>2024.08.19 ~ 2024.08.26</h2><h3>🎨 Swifter for SwiftUI 정리</h3><hr /><ul><li>🔗 <a href="https://apps.apple.com/us/app/swifter-for-swiftui/id1621133381?l=ko">Swifter for SwiftUI</a></li></ul><p>Swifter for SwiftUI라는 SwiftUI를 개발할 때 SwiftUI의 Component 설명, 기본 사용법, Tip들을 간단하게 정리해놓은 앱을 보며 정리해봤다.</p><p>유료결제를 해야 모든 내용이 보여 결제 후 정리했다. OS 업데이트에 맞춰서 내용이 대응이 안되있는 부분들도 있지만 만족했다.</p><p>그리고 정리 후 이번 사이드프로젝트에 SwiftUI를 적용했다.</p><p>SwiftUI와 TCA아키텍처를 자주 사용하는 것 같아서 TCA와 관련된 링크들을 찾아봤다.</p><ol><li>🔗 <a href="https://gist.github.com/Achoo-kr/5d8936d12e71028fcc4a7c5e078ca038">pointfreeco -ReadMe Korean</a></li><li>🔗 <a href="https://www.pointfree.co/collections/composable-architecture">pointfreeco - 동영상 강의</a></li><li>🔗 <a href="https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/">pointfreeco - Tutorial</a></li><li>🔗 <a href="https://ridibooks.com/books/2773000087">TCA 한글 e-book</a></li></ol><h3>🔐 Supabase Auth</h3><hr /><p>Firebase의 대항마로 최근 떠오르는 Supabase를 이번에 사이드프로젝트에 적용해보기로 했다.</p><p>기존에 FirebaseAuth + SwiftUI 로 로그인기능을 구현한 프로젝트가 있었는데 거의 바꿀 부분은 인스턴스만 변경하고 메서드가 거의 동일했다.</p><p>Supabase Auth에서 가장 큰 특징은 카카오 인증이 있는 부분이 신기했다.</p><p>사이드프로젝트에서 이메일로 회원가입, 로그인, 로그아웃까지 적용했다.</p><h3>📃 SwiftPM 관련 글 작성</h3><hr /><p>🔗 <a href="https://sookim-1.tistory.com/entry/iOS-SwiftPM-SwiftPackage-1">SwiftPM - SwiftPackage</a></p><p>SwiftPackage, SwiftPM, SwiftPackage를 만드는 방법, 간단한 구조에 대한 설명을 작성했다.</p><p>🔗 <a href="https://sookim-1.tistory.com/entry/SwiftPM-PackageCollection">SwiftPM - PackageCollection</a>PackageCollection을 만들어 쉽게 Package목록을 추가하는 방법과 서명을 추가하는 방법에 대해 작성했다.</p><p>PackageCollection을 사용하는 방법에 대해서 WWDC 영상에 매우 친절하게 설명하지만, 서명을 추가하는 방법은 없어서 자세히 작성했다.</p><p>해당 글을 정리한 후, 직접 사용 중인 DesignSystem에 비공개로 SwiftPackage를 배포했다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>🔗 <a href="https://gist.github.com/sookim-1/a3f22fa6c8bee5120e4ecdf663f81f36">.gitignore의 스니펫</a>이 보기가 힘들어서 주석을 추가하여 정리했다.</li><li>iOS앱의 접근권한 중 카메라 권한을 변경하면 앱이 Refresh 되는 것 같다. (다른 접근권한들도 확인해봐야겠다.) 또한, 권한요청을 한 번 했어도 TestFlight에서 앱을 계속 다운로드 받다보면 가끔씩 🔗 <a href="https://developer.apple.com/documentation/corelocation/cllocationmanager/authorizationstatus-swift.property">AuthorizationStatus</a>가 notDetermined가 되는 경우가 있다.</li><li>Firebase Crashlytics에서 objc_retain이라는 이슈가 있어서 확인해보았는데 Zombie객체에 접근할 때 발생하는 이슈였다. 메모리가 해제되었는데 접근할 때 Crash가 발생한다고 한다. Xcode Instrument를 통해 확인해볼 수 있다는 데, 좀 더 봐야될 것 같다.</li><li>Github Action을 iOS앱개발자입장에서 어떻게 사용할 지 고민해봤다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/030-20240827_en</guid><title>Number: 030, Date: 2024-08-27</title><link>https://sookim-1.github.io/en/030-20240827_en</link><description><![CDATA[🔗 Swifter for SwiftUI]]></description><pubDate>Tue, 27 Aug 2024 12:10:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[SwiftPM]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Supabase]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[TCA]]></category><category><![CDATA[Git]]></category><category><![CDATA[Github]]></category><category><![CDATA[Firebase]]></category><category><![CDATA[Access Permissions]]></category><content:encoded><![CDATA[<h2>2024.08.19 ~ 2024.08.26</h2><h3>🎨 Organizing Swifter for SwiftUI</h3><hr /><ul><li>🔗 <a href="https://apps.apple.com/us/app/swifter-for-swiftui/id1621133381?l=ko">Swifter for SwiftUI</a></li></ul><p>I reviewed the Swifter for SwiftUI app, which organizes explanations, basic usage, and tips for SwiftUI components while developing with SwiftUI.</p><p>I needed to make a paid subscription to access all content and organized it after the purchase. There were some parts not aligned with the OS updates, but overall, I was satisfied.</p><p>After the organization, I applied SwiftUI to this side project.</p><p>Since I often use SwiftUI and the TCA architecture, I looked for links related to TCA.</p><ol><li>🔗 <a href="https://gist.github.com/Achoo-kr/5d8936d12e71028fcc4a7c5e078ca038">pointfreeco - ReadMe Korean</a></li><li>🔗 <a href="https://www.pointfree.co/collections/composable-architecture">pointfreeco - Video Lectures</a></li><li>🔗 <a href="https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/">pointfreeco - Tutorial</a></li><li>🔗 <a href="https://ridibooks.com/books/2773000087">TCA Korean e-book</a></li></ol><h3>🔐 Supabase Auth</h3><hr /><p>I decided to apply Supabase, which is emerging as a competitor to Firebase, in my side project.</p><p>I previously implemented login functionality using FirebaseAuth + SwiftUI, and the changes involved mainly switching instances; the methods remained almost identical.</p><p>A notable feature of Supabase Auth is its Kakao authentication, which I found interesting.</p><p>In my side project, I implemented email signup, login, and logout functionalities.</p><h3>📃 Writing about SwiftPM</h3><hr /><p>🔗 <a href="https://sookim-1.tistory.com/entry/iOS-SwiftPM-SwiftPackage-1">SwiftPM - SwiftPackage</a></p><p>I wrote about how to create Swift Packages and SwiftPM, along with a brief structure description.</p><p>🔗 <a href="https://sookim-1.tistory.com/entry/SwiftPM-PackageCollection">SwiftPM - PackageCollection</a></p><p>I wrote about creating PackageCollections for easy addition of package lists and how to add signatures.</p><p>Although WWDC videos explain how to use PackageCollections very well, they lack details on how to add signatures, so I elaborated on that.</p><p>After organizing this content, I privately distributed a SwiftPackage in the DesignSystem I’m currently using.</p><h3>🙋🏻‍♂️ Other Matters</h3><hr /><ol><li>I added comments to my 🔗 <a href="https://gist.github.com/sookim-1/a3f22fa6c8bee5120e4ecdf663f81f36">Snippet for .gitignore</a> to make it easier to read.</li><li>It seems that changing the camera permission among the iOS app’s access permissions causes the app to refresh. (I need to check other permissions as well.) Additionally, even if permission has been requested once, sometimes in TestFlight, the app will still download with the 🔗 <a href="https://developer.apple.com/documentation/corelocation/cllocationmanager/authorizationstatus-swift.property">AuthorizationStatus</a> showing as notDetermined.</li><li>I reviewed an issue in Firebase Crashlytics related to <code>objc_retain</code>, which occurs when accessing a Zombie object. It crashes when accessing an object that has been deallocated. I heard it can be checked using Xcode Instruments, but I need to explore it further.</li><li>I considered how to use Github Actions from the perspective of an iOS app developer.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/029-20240819</guid><title>번호 : 029, 작성일자: 2024-08-19</title><link>https://sookim-1.github.io/ko/029-20240819</link><description><![CDATA[기존프로젝트에 Tuist를 적용하기 위해서 준비할 파일들은 Default에서 변경된 값이 있다면 Info.plist, xcconfig 파일이 있다.]]></description><pubDate>Mon, 19 Aug 2024 19:40:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Tuist]]></category><category><![CDATA[Blog]]></category><content:encoded><![CDATA[<h2>2024.08.12 ~ 2024.08.18</h2><h3>⚙️ Tuist</h3><hr /><p>기존프로젝트에 Tuist를 적용하기 위해서 준비할 파일들은 Default에서 변경된 값이 있다면 Info.plist, xcconfig 파일이 있다.</p><p>Info.plist를 추출하기 편리하게 하기 위해 Xcode Target - Build Setting - Generate info.plist File을 No로 설정한 후 Info탭에 존재하는 키값들을 Xcode Navigator영역에 존재하는 Info.plist로 옮겨주었다.</p><pre><code class="language-bash"># Target 빌드 셋팅 추출
$ tuist migration settings-to-xcconfig -p Project.xcodeproj -t MyApp -x MyApp.xcconfig

# 프로젝트 빌드 셋팅 추출
$ tuist migration settings-to-xcconfig -p Project.xcodeproj -x MyAppProject.xcconfig
</code></pre><p>해당 명령어를 통해 xcconfig파일을 추출했다.</p><ul><li>.gitignore에 *.xcodeproj, *.xcworkspace, Derived/ 를 추가한 후 Project.swift를 작성했다.</li><li>간단히, Tuist Project의 Sources와 Resources 매개변수는 각각 Compile Sources, Copy Bundle Resources에 추가되기 때문에 프로젝트의 파일분리가 잘되어있지 않은 경우, 와일드카드를 활용하여 해결할 수 있다.</li><li>파일이 삭제할 때 제대로 삭제되지 않은 경우, Xcode Navigator 영역에 표시되지 않는 미추적되는 파일들은 제외하거나 삭제해줘야 한다.</li><li>TargetScript를 작성할 때 script를 직접 작성하여 추가할 지, script파일을 만들어 연결을 시킬지는 각각 장단점이 있는 것 같다. script를 직접 작성하면 Xcode에서 바로 확인 할 수 있는 부분이 좋은 것 같지만 변경사항이 제대로 적용되지 않는 것 같다.<ul><li>Swift Package Plugin - Build Tool Plugin을 사용하는 경우 Tuist Target에서 Dependency 인자에 plugin을 추가해줄 수 있다.</li></ul></li></ul><p>의존성관리도구로 CocoaPods, Carthage를 사용하지 않고 프로젝트파일들이 Swift파일로 구성되어 있는 경우, 큰 어려움이 없이 Tuist를 적용할 수 있었다.</p><p>Tuist에 관련된 글을 작성한 블로그 글 중 해외와 국내 비중을 계산하면 국내 비중이 월등히 높은 것 같다. 또한, 몇몇 글 중 Tuist 관련 객체 초기화메서드를 Custom해서 사용하는 글들이 많았는 데, 중복되는 부분들을 반복해서 작성하지 않아서 좋은점도 있지만, 메서드를 확인하여 어떤 부분들을 변경했는 지 확인하는 부분들은 불편한 것 같다. 상황에 따라 유용한 방법을 사용해야 겠다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>링크드인에 🔗 <a href="[https://www.linkedin.com/posts/sookim1_개발블로그를-시작하려고-할-때-잘못된-정보를-공유하는-것에-대한-두려움-activity-7229460165526175744-Dyn-?utm_source=share&utm_medium=member_desktop](https://www.linkedin.com/posts/sookim1_%EA%B0%9C%EB%B0%9C%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A0%A4%EA%B3%A0-%ED%95%A0-%EB%95%8C-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B3%B5%EC%9C%A0%ED%95%98%EB%8A%94-%EA%B2%83%EC%97%90-%EB%8C%80%ED%95%9C-%EB%91%90%EB%A0%A4%EC%9B%80-activity-7229460165526175744-Dyn-?utm_source=share&utm_medium=member_desktop)">블로그 게시글에 잘못된 내용을 포함해도 되는이유</a>에 관한 업데이트를 작성했다.</li><li>🔗 <a href="https://www.youtube.com/@user-wi3bv5zr9g">코딩도우미 유튜브 채널</a>에 올라오는 Medium관련 글들 중 유용한 글들을 나의 Medium List에 추가했다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/029-20240819_en</guid><title>Number: 029, Date: 2024-08-19</title><link>https://sookim-1.github.io/en/029-20240819_en</link><description><![CDATA[To apply Tuist to an existing project, files like Info.plist and xcconfig need to be prepared if there are any custom values different from the default settings.]]></description><pubDate>Mon, 19 Aug 2024 19:40:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Tuist]]></category><category><![CDATA[Blog]]></category><content:encoded><![CDATA[<h2>2024.08.12 ~ 2024.08.18</h2><h3>⚙️ Tuist</h3><hr /><p>To apply Tuist to an existing project, files like <code>Info.plist</code> and <code>xcconfig</code> need to be prepared if there are any custom values different from the default settings.</p><p>I made it easier to extract the <code>Info.plist</code> by setting <strong>Xcode Target</strong> -> <strong>Build Settings</strong> -> <strong>Generate info.plist File</strong> to <strong>No</strong>, then manually moved the key-value pairs from the Info tab to the <code>Info.plist</code> in Xcode’s Navigator panel.</p><p>Commands to extract build settings:</p><pre><code class="language-bash"># Extract target build settings.
$ tuist migration settings-to-xcconfig -p Project.xcodeproj -t MyApp -x MyApp.xcconfig

# Extract project build settings.
$ tuist migration settings-to-xcconfig -p Project.xcodeproj -x MyAppProject.xcconfig
</code></pre><p>Using the extracted configurations, I created the <code>xcconfig</code> files.</p><ul><li>After adding <code>*.xcodeproj</code>, <code>*.xcworkspace</code>, and <code>Derived/</code> to <code>.gitignore</code>, I wrote the <code>Project.swift</code> file.</li><li>In Tuist projects, the <code>Sources</code> and <code>Resources</code> parameters are automatically mapped to <strong>Compile Sources</strong> and <strong>Copy Bundle Resources</strong>, respectively. If the project files are not well-organized, wildcard patterns can be used to simplify things.</li><li>When deleting files, untracked files that no longer appear in Xcode Navigator must be excluded or removed.</li><li>When writing a Target Script, you can either write the script directly or link to a script file. Each method has its pros and cons. Writing directly allows immediate viewing in Xcode, but changes may not apply correctly.<ul><li>If using <strong>Swift Package Plugin - Build Tool Plugin</strong>, the plugin can be added to the dependency parameter of the Tuist target.</li></ul></li></ul><p>If your project is composed entirely of Swift files and does not rely on dependency managers like CocoaPods or Carthage, applying Tuist can be done smoothly.</p><p>Interestingly, the proportion of Tuist-related blog posts is much higher in Korea than overseas. Many of these posts customize Tuist object initialization methods to avoid writing redundant code, which is helpful. However, it can be inconvenient to identify what changes were made within the methods. It’s essential to choose the right approach depending on the situation.</p><h3>🙋🏻‍♂️ Other Matters</h3><hr /><ol><li>I posted a LinkedIn update 🔗 <a href="https://www.linkedin.com/posts/sookim1_개발블로그를-시작하려고-할-때-잘못된-정보를-공유하는-것에-대한-두려움-activity-7229460165526175744-Dyn-?utm_source=share&utm_medium=member_desktop">Why It’s Okay to Include Incorrect Information in Blog Posts</a>.</li><li>I added useful articles related to Medium from the 🔗 <a href="https://www.youtube.com/@user-wi3bv5zr9g">Coding Helper YouTube Channel</a> to my Medium list.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/028-20240812</guid><title>번호 : 028, 작성일자: 2024-08-12</title><link>https://sookim-1.github.io/ko/028-20240812</link><description><![CDATA[지난 주 프로젝트의 의존성관리도구를 CocoaPods에서 SwiftPM으로 Migration을 모두 완료해서 새로운 문제가 없는지 안정성 테스트를 진행했다.]]></description><pubDate>Mon, 12 Aug 2024 23:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Cocoa Pods]]></category><category><![CDATA[Swift Package]]></category><category><![CDATA[Git]]></category><category><![CDATA[Github]]></category><category><![CDATA[Bitbucket]]></category><content:encoded><![CDATA[<h2>2024.08.06 ~ 2024.08.11</h2><h3>⚙️ SwiftPM 안정성 테스트</h3><hr /><p>지난 주 프로젝트의 의존성관리도구를 CocoaPods에서 SwiftPM으로 Migration을 모두 완료해서 새로운 문제가 없는지 안정성 테스트를 진행했다.</p><p>변경을 모두 완료한 뒤 실제로 적용을 고려하기 위해 의존성관리도구 별로 각각의 차이점을 한 번 더 정리를 해봤다.</p><p>iOS 프로젝트에서 의존성관리도구로는 보통 3가지(CocoaPods, Carthage, SwiftPM)를 사용한다.</p><p>일단 Carthage도 장단점을 비교했지만, 지원하지 않는 라이브러리가 많기 때문에 사용을 고려하는 부분에서는 제외했다.</p><p>CocoaPods의 장점이 SwiftPM이 처음 출시했을 때는 Dynamic, Static 라이브러리를 모두 지원하고, CocoaPods를 지원하는 라이브러리가 많고, 해당 정보들도 많은 장점들이 있었지만 현재 날짜 기준으로는 해당 장점들이 모두 없어진 것 같다.</p><p>SwiftPM은 또한 Swift언어에 Built-in 되어있어 따로 설치하지 않아도 되고 애플이 공식적으로 지원하는 등 여러가지 장점이 있는 것 같다. 예외로는 Swift언어가 아닌 라이브러리를 사용할 때 불편한 단점이 있어서 해당 부분은대체할 수 없이 CocoaPods를 사용해야 할 것 같다.</p><blockquote><p>빌드시간 확인</p></blockquote><p>CocoaPods에서 SwiftPM으로 Migration을 한 후 SwiftPM은 의존성을 체크하는 과정이 없어 빌드시간이 더 빠르다고 하여서 실제로 빌드시간을 각각 체크해보았다.</p><p>첫 빌드시간 과 재빌드시간을 모두 측정해보았다.</p><p>Terminal에서 빌드시간 측정</p><pre><code class="language-bash"># SwiftPM 빌드시간 측정
$ time xcodebuild build -project SwiftPMProject.xcodeproj -scheme SwiftPMProject

# CocoaPods 빌드시간 측정
$ time xcodebuild build -workspace PAPA.xcworkspace -scheme PAPA
</code></pre><p>Xcode에서 빌드시간 측정</p><pre><code class="language-bash">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES
</code></pre><p>하지만, 결과는 의외로 첫빌드, 재빌드 모두 유사했다. 오히려 CocoaPods가 빌드시간이 더 빠른 경우도 있었다.</p><p>🔗 <a href="https://medium.com/@golddol2003/cocoapods-vs-spm-ba7b7478236b">CocoaPods vs SPM</a> 글을 참고한 결과 SwiftPM이 CocoaPods보다 빌드시간이 느려질 수 도 있는 이유는 SwiftPM은 모든 의존성을 빌드를 수행하는데 복잡한 의존성 그래프인 경우 더 느려질 수도 있다고 한다.</p><h3>🏃 Git Repository 이동 && Git Author 전체변경</h3><hr /><p>Git을 사용할 때 Commit의 모든 변경내역을 포함하여 Repository를 간단하게 이동시키는 방법을 찾았다.</p><pre><code class="language-bash">$ git clone --mirror https://github.com/sookim-1/originalRepo.git

// .git 폴더가 생기는데 해당 폴더로 이동
$ cd originalRepo.git

$ git remote set-url origin https://github.com/sookim-1/newRepo.git

$ git push --mirror
</code></pre><p>주의사항은 Github에서는 한 파일당 100Mb가 넘는다면 git-lfs를 사용하여 업로드를 해야하는데 git-lfs란? 대용량 파일을 텍스트포인터로 대체하여 올리는 방식이다.</p><p>하지만 gif-lfs를 저장하는 Storage는 Github에서 무료요금제의 경우 20일당 1Gb로 제한되어있다. data-pack을 5달러로 구매하면 50Gb로 업그레이드 할 수 있다.</p><p>용량이 초과한 경우, 용량을 초과한 Repository를 제거해도 초기화되는데 시간이 조금 걸리는 것 같다. 이전에는 수동으로 요청해서 제거했었다고 하는데 자동화가 되면서 느려진 것일수도 있을 것 같다.</p><pre><code class="language-bash">$ git lfs install

// 원하는 파일들 lfs 추가 
$ git lfs migrate import --include="Large/*, *.zip" --everything

$ git push --mirror
</code></pre><blockquote><p>git-filter-repo</p></blockquote><p>git-filter-repo란? 편리하게 커밋 기록들을 필터링하고 수정하는데 도움을 주는 툴이다.</p><p>해당 툴을 사용하여 잘못된 author를 쉽게 일괄 변경할 수 있고 커밋별 제거할 파일들도 일괄로 제거할 수 있었다.</p><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>NHN Cloud, Naver Clova 각각 3rd-party 플랫폼의 사용량을 확인하는 방법에 대해서 알아보았다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/028-20240812_en</guid><title>Number: 028, Date: 2024-08-12</title><link>https://sookim-1.github.io/en/028-20240812_en</link><description><![CDATA[Last week, I completed the migration of the dependency manager in the project from CocoaPods to SwiftPM, and I ran stability tests to check for any new issues.]]></description><pubDate>Mon, 12 Aug 2024 23:00:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Cocoa Pods]]></category><category><![CDATA[Swift Package]]></category><category><![CDATA[Git]]></category><category><![CDATA[Github]]></category><category><![CDATA[Bitbucket]]></category><content:encoded><![CDATA[<h2>2024.08.06 ~ 2024.08.11</h2><h3>⚙️ SwiftPM Stability Test</h3><hr /><p>Last week, I completed the migration of the dependency manager in the project from CocoaPods to SwiftPM, and I ran stability tests to check for any new issues.</p><p>After finishing the changes, I organized the pros and cons of each dependency manager to see which one would work best in practice.</p><p>Typically, iOS projects use three dependency managers: CocoaPods, Carthage, and SwiftPM.</p><p>While I also compared Carthage, it was excluded from consideration due to the many libraries it does not support.</p><p>Initially, CocoaPods had advantages over SwiftPM, such as supporting both dynamic and static libraries and having broad library support and documentation. However, as of today, many of these advantages no longer apply.</p><p>On the other hand, SwiftPM comes with several benefits, including being built into Swift and officially supported by Apple. One notable drawback is that it’s not convenient for non-Swift libraries, meaning I may still need CocoaPods for such cases.</p><blockquote><p>Build Time Analysis</p></blockquote><p>After migrating from CocoaPods to SwiftPM, I measured the build time, as SwiftPM is said to be faster due to skipping dependency checks.</p><p>I measured both the initial build time and rebuild time.</p><p>Terminal commands for build time measurement:</p><pre><code class="language-bash"># Measuring build time for SwiftPM
$ time xcodebuild build -project SwiftPMProject.xcodeproj -scheme SwiftPMProject

# Measuring build time for CocoaPods
$ time xcodebuild build -workspace PAPA.xcworkspace -scheme PAPA
</code></pre><p>To check the build time in Xcode</p><pre><code class="language-bash">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES
</code></pre><p>However, the results were surprising. Both the initial build and rebuild times were similar, and in some cases, CocoaPods was actually faster.</p><p>According to the article 🔗 <a href="https://medium.com/@golddol2003/cocoapods-vs-spm-ba7b7478236b">CocoaPods vs SPM</a>, one possible reason why SwiftPM may have slower build times compared to CocoaPods is that SwiftPM builds all dependencies. If the dependency graph is complex, this can slow down the build process.</p><h3>🏃 Migrating Git Repository & Batch Updating Git Author</h3><hr /><p>I found a simple way to migrate a Git repository while retaining all commit history.</p><pre><code class="language-bash">$ git clone --mirror https://github.com/sookim-1/originalRepo.git

# A .git folder will be created, navigate into it
$ cd originalRepo.git

$ git remote set-url origin https://github.com/sookim-1/newRepo.git

$ git push --mirror
</code></pre><p>One caveat is that if any single file exceeds 100MB on GitHub, you need to use git-lfs (Large File Storage), which stores large files as text pointers.</p><p>For free GitHub accounts, git-lfs storage is limited to 1GB every 20 days. You can upgrade to 50GB by purchasing a $5 data pack.</p><p>If you exceed the storage limit, deleting the oversized repository may take some time before the quota resets. In the past, this process had to be manually requested, but with automation, it may have slowed down.</p><pre><code class="language-bash">$ git lfs install

# Add the files you want to store with lfs
$ git lfs migrate import --include="Large/*, *.zip" --everything

$ git push --mirror
</code></pre><blockquote><p>git-filter-repo</p></blockquote><p>git-filter-repo is a tool that helps filter and modify commit history conveniently.</p><p>With this tool, I was able to batch update incorrect author information and remove unwanted files across multiple commits.</p><h3>🙋🏻‍♂️ Other Matters</h3><hr /><ol><li>I researched how to track the usage of third-party platforms like NHN Cloud and Naver Clova.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/ko/027-20240806</guid><title>번호 : 027, 작성일자: 2024-08-06</title><link>https://sookim-1.github.io/ko/027-20240806</link><description><![CDATA[의존성관리도구로 CocoaPods을 사용 중인 프로젝인 경우 Tuist를 도입을 생각 중이라면 SwiftPM이 작업하기 수월하고 빌드시간단축도 되기 때문에 장점을 고려하면 Migration을 할 수 있다.]]></description><pubDate>Tue, 06 Aug 2024 06:35:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Cocoa Pods]]></category><category><![CDATA[Swift Package]]></category><category><![CDATA[Resume]]></category><category><![CDATA[Github]]></category><category><![CDATA[Bitbucket]]></category><content:encoded><![CDATA[<h2>2024.07.29 ~ 2024.08.05</h2><h3>⚙️ CocoaPods → SwiftPM</h3><hr /><p>의존성관리도구로 CocoaPods을 사용 중인 프로젝인 경우 Tuist를 도입을 생각 중이라면 SwiftPM이 작업하기 수월하고 빌드시간단축도 되기 때문에 장점을 고려하면 Migration을 할 수 있다.</p><p>일단 CocoaPods에서 SwiftPM으로 전환한다면 프로젝트에서 설치된 Pod과 Product를 정리한다.</p><p>그리고 발생하는 몇몇 상황에 대비해야한다.</p><ol><li>Swift Package에 설치되는 의존성버전들이 충돌되는 경우<br></br>🔗 <a href="https://github.com/sacOO7/socketcluster-client-swift">socket-cluster</a> 라이브러리는 업데이트가 지속적으로 되지 않아서 내부 Test타겟에서 RxSwift버전이 낮아 라이브러리 설치가 되지않았다.<br></br>그래서 🔗 <a href="https://github.com/sookim-1/socketcluster-client-swift">Test타겟을 제거한 Repository</a>로 설치했다.</li><li>SwiftPM을 지원하지 않는 라이브러리가 있는 경우<br></br>🔗 <a href="https://github.com/navermaps/ios-map-sdk">NaverMap iOS SDK</a>는 SwiftPM을 지원하지 않아서 검색 도중 🔗 <a href="https://github.com/jaemyeong/NMapsMap">지원하는 Repository</a>로 설치했다.</li></ol><p>모든 Swift Package를 설치한 후 추후 작업을 위해 Package Collection을 생성했다.</p><p><strong><code>Package Collection</code></strong></p><p>Package Collection을 생성할 때 🔗<a href="https://developer.apple.com/videos/play/wwdc2021/10197/">WWDC</a>에 설명이 잘되어 있었지만 서명을 추가하는 부분이 복잡했다.</p><ol> 
   <li>Swift Package Collection Certificate를 발급한다.</li>  
   <li>키체인에 등록 후 개인키 .p12 파일을 .pem으로 openssl로 변환한다. (openssl이 1버전대라면 그대로 사용이가능하지만 3버전대라면 -legacy 옵션을 추가한다.)</li>  
   <li>중간인증서와 루트인증서와 함께 package-collection-sign 명령어를 실행한다.</li>
</ol>
<p><strong><code>SwiftPM Migration 작업 순서</code></strong></p><ol> 
   <li>CocoaPods, Pod 관련 파일들을 제거했다.</li>  
   <li>🔗 [R.Swift라이브러리](https://github.com/mac-cain13/R.swift)를 사용하는 경우 SwiftPM에서는 R.generated.swift를 적용하는 Build Script를 제거한 후 Swift Package Build Tool Plugin으로 변경했다.</li>  
   <li>Firebase Crashlytics dSym을 업로드하는 빌드스크립트를 SwiftPM에 맞도록 변경했다.</li>
   <li>Objective-C 라이브러리를 사용하지 않는 경우 Bridging-Header.h를 제거했다.</li>
   <li>License Plist 라이브러리를 설치한 SwiftPM으로 업데이트했다.</li>
</ol>
<h3>📃 이력서 피드백</h3><hr /><p>작성한 이력서에 대해 동료에게 피드백을 받았다.</p><p><strong><code>정리</code></strong></p><ul><li>간단소개글 및 자기소개는 문장의 느낌으로 작성한다.</li><li>도메인을 이해한 사람만 아는 용어는 자제한다.</li><li>Udacity - Nano Degree 강의들은 도움이 된다.</li><li><code>개발자기술면접노트</code> 라는 최근 나온 도서가 도움이 된다.</li></ul><h3>🙋🏻‍♂️ 기타 사항</h3><hr /><ol><li>Bitbucket은 Cloud와 DataCenter로 나누어지는데 Cloud는 SaaS 제품이고, DataCenter는 설치형제품이다. 각종 제공되는 기능이 다른 부분들이 있다.</li><li>상용한글은 2350자로 구성되어있다.</li><li>Github gist 같은 기능을 Bitbucket에도 Snippet이라고 있다. gist는 public으로 전환 후에는 secret으로 변경이 되지 않는다.</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://sookim-1.github.io/en/027-20240806_en</guid><title>Number: 027, Date: 2024-08-06</title><link>https://sookim-1.github.io/en/027-20240806_en</link><description><![CDATA[For projects using CocoaPods as a dependency manager, if you are considering adopting Tuist, migrating to SwiftPM might be easier and can reduce build time. Given its advantages, migration is worth considering.]]></description><pubDate>Tue, 06 Aug 2024 06:35:00 +0000</pubDate><dc:creator><![CDATA[sookim-1]]></dc:creator><category><![CDATA[iOS]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Blog]]></category><category><![CDATA[Cocoa Pods]]></category><category><![CDATA[Swift Package]]></category><category><![CDATA[Resume]]></category><category><![CDATA[Github]]></category><category><![CDATA[Bitbucket]]></category><content:encoded><![CDATA[<h2>2024.07.29 ~ 2024.08.05</h2><h3>⚙️ CocoaPods → SwiftPM</h3><hr /><p>For projects using CocoaPods as a dependency manager, if you are considering adopting Tuist, migrating to SwiftPM might be easier and can reduce build time. Given its advantages, migration is worth considering.</p><p>When switching from CocoaPods to SwiftPM, start by organizing the Pods and Products installed in the project.</p><p>Also, be prepared for a few situations:</p><ol><li><strong>Version conflicts in dependencies installed via Swift Package</strong><br></br>For example, the 🔗 <a href="https://github.com/sacOO7/socketcluster-client-swift">socket-cluster</a> library hasn’t been continuously updated, and the internal test target uses an outdated version of RxSwift, making the library incompatible.<br></br>Thus, I installed it from 🔗 <a href="https://github.com/sookim-1/socketcluster-client-swift">my own repository</a> that removes the test target.</li><li><strong>Libraries that do not support SwiftPM</strong><br></br>🔗 <a href="https://github.com/navermaps/ios-map-sdk">NaverMap iOS SDK</a> does not support SwiftPM, but I found a 🔗 <a href="https://github.com/jaemyeong/NMapsMap">supported repository</a> for installation.</li></ol><p>After installing all Swift Packages, I created a Package Collection for future use.</p><p><strong><code>Package Collection</code></strong></p><p>While creating the Package Collection, I found the 🔗<a href="https://developer.apple.com/videos/play/wwdc2021/10197/">WWDC</a> explanation helpful, though adding the signature was a bit complex.</p><ol> 
   <li>Obtain a Swift Package Collection Certificate.</li>  
   <li>Register the certificate in Keychain, then convert the .p12 private key file to .pem using OpenSSL (if using OpenSSL version 1, you can use it as is; for version 3, add the -legacy option).</li>  
   <li>Run the package-collection-sign command with the intermediate and root certificates.</li>
</ol>
<p><strong><code>SwiftPM Migration Steps</code></strong></p><ol> 
   <li>Removed CocoaPods and Pod-related files.</li>  
   <li>When using 🔗 [R.Swift library](https://github.com/mac-cain13/R.swift), replace the R.generated.swift Build Script with the Swift Package Build Tool Plugin.</li>  
   <li>Updated the Firebase Crashlytics dSym upload script to be compatible with SwiftPM.</li>
   <li>Removed Bridging-Header.h if Objective-C libraries are not being used.</li>
   <li>Updated License Plist to be installed via SwiftPM.</li>
</ol>
<h3>📃 Resume Feedback</h3><hr /><p>I received feedback from a colleague on my resume.</p><p><strong><code>Summary</code></strong></p><ul><li>Write the introduction and self-introduction as complete sentences.</li><li>Avoid using jargon that only someone familiar with the domain would understand.</li><li>Udacity’s Nano Degree courses are helpful.</li><li>The recently published book <code>Developer Technical Interview Notes</code> is recommended.</li></ul><h3>🙋🏻‍♂️ Other Matters</h3><hr /><ol><li>Bitbucket is divided into Cloud (SaaS product) and DataCenter (on-premise product), and there are differences in the provided features.</li><li>The commonly used Hangul consists of 2,350 characters.</li><li>Bitbucket has a feature similar to Github gist, called Snippet. Note that once a gist is made public, it cannot be changed back to secret.</li></ol>]]></content:encoded></item></channel></rss>